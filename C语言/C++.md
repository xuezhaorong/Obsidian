## 进入c++
```c
#include <iostream>  
using namespace std;  
  
int main() {  
    int carrots;  
    cin >> carrots;  
    cout << "Hello, World!" << endl;  
    return 0;  
}
```

包含以下元素：
* iostream：包含输入输出的多个定义
* using命名空间：不用使用std::cout 等
* cout输出和cin输入
* 换行符`endl`

##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

#### **整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = '/f'`
ASKII码表达方式: `char grade = 65`
八进制表达方式： `char grade = '\007'`
十六进制表达方式： `char grade = '\0x010'`

### 浮点型

|  数据类型  | 表达方式 | 存储大小 |
| :----: | :--: | :--: |
| float  |  f   |  32  |
| double |  f   |  64  |

存储结构：
浮点型先转成二进制数再使用科学计数法表达
例如：$-8.25=1000.01=-1.00001 * 2^{3}$

* 符号位为：1
* 指数位为：3+127=130=10000010 使用偏移法，+127解决负指数没有符号位存储的问题 范围为 `-126` 到 `127`（用偏移量127表示的范围是 `1` 到 `254`），`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`）。
* 尾数位为：00001，
则内存表示为：
![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/2024/09/19/14-50-54-6a9d287590962e528826adde6f945edd-11-48-32-6a9d287590962e528826adde6f945edd-20240914114831-bff660-de426b.png)
`float`用1位表示符号位，8位表示指数位，23位标识尾数位
`double`用1位表示符号位，8位表示指数位，23+32位标识尾数位

#### 单精度浮点数可表示的最大值：
为了求出单精度浮点数能表示的最大值，我们需要让指数和尾数都达到它们的最大值。

**1. 最大尾数**

尾数由 23 位表示，加上隐含的前导 `1`，最大尾数可以表示为：

$1.111…111(23 个 1)$

这个尾数表示的值是接近于 2 的值，即：

$1.111…111=2−2^{−23}$

**2. 最大指数**

8 位的指数位可以表示的范围是 `0` 到 `255`。但是，`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`），所以指数的有效范围是 `1` 到 `254`。

在偏移 127 的情况下，最大可表示的指数值为：

$254−127=127$

这意味着指数部分表示的最大值为 $2^{127}$。

**3. 计算最大浮点数值**

将最大指数和最大尾数带入公式：

$最大浮点数=(2−2^{−23})×2^{127}$

简化后，这个值非常接近于：

$最大浮点数≈2×2^{127}=2^{128}$

转换为十进制：

$2^{128}≈3.4028235×10^{38}$

因此，单精度浮点数的最大可表示值大约是 $**3.4 × 10^{38}**$。

#### 浮点型溢出

**浮点型的上溢：**
在单精度浮点数（32位）的情况下，结果超出可表示的最大值，通常会被处理为 `inf`。

**浮点型的下溢：**
当除以一个非常小的数或非常大的数时，会遇到 **下溢（underflow）** 的问题。在这种情况下，数值会进入 **非正规数（subnormal）** 的范围。

通常，浮点数是按照 **规范化**（normalized） 的形式表示的。规范化的浮点数必须是以1开头的二进制数，形式为：
$(−1)^{sign}×1.fraction×2^{exponent−127}$

**非正规数（subnormal number）**：当浮点数太小，以至于不能再用 `1.xxx` 这种形式表示时，指数达到最小值 `0`，并且尾数的格式变为 `0.xxx`。此时，浮点数的表示不再遵循规范化的形式，而是：
$(−1)^{sign}×0.fraction×2^{−126}$
这是为了能够表示比最小正常数更小的数值，但代价是**精度降低**，因为不再有隐含的 `1` 作为尾数的起点。

当我们将一个 **非常小** 的浮点数除以 2 时，指数部分应该减小。但如果这个数已经是最小指数（`-126`）的正常数，再继续将它除以 2，将导致数值小于能表示的最小正常数，这时浮点数进入了 **非正规数** 的区域。

**非正规数的行为**：非正规数的指数不再减小，指数保持为 `-126`，而是通过尾数的移位来减小数值。这意味着当我们将数除以2时，尾数部分的位会向右移，最右边的位会被丢弃，精度也因此降低。

例如：
假设最小的正常数是： 
$1.00000000000000000000000×2^{−126}$

将这个数除以 2 后，我们得到： 
$0.10000000000000000000000×2^{−126}$

因为尾数不再能表示 `1.0000...` 这种形式，而是 `0.1000...`，所以它变成了非正规数。
继续下溢：

如果我们继续将这个非正规数除以 2，尾数会进一步右移，最终所有的位会变成 `0`，结果是： $0.000000000000000000000002×2^{−126} = 0$

这就是下溢的最终结果——当尾数的精度已经不足，进一步的运算将导致数值接近或等于零。

#### **舍入误差：**
```c
#include <stdio.h> 
int main(void) { 
	float a,b; 
	b = 2.0e20 + 1.0; 
	a = b - 2.0e20; 
	printf("%f \n", a); return 0; 
}
```

当我们对一个非常大的数（如 `2.0e20`）加上一个非常小的数（如 `1`）时，**精度不足** 导致了计算误差。
- `2.0e20` 表示 `2 × 10^20`，它等于 **2后面跟着20个零**，即 `200000000000000000000`。
- 如果我们对 `2.0e20` 加上 `1`，从数学上来说，结果应该是 `200000000000000000001`。

但是，**问题在于浮点数精度的限制**。对于一个像 `2.0e20` 这么大的数，计算机只能存储前 6-7 位有效数字，后面的数字则被舍入。因此，当我们加 `1` 时，计算机没有足够的位数来存储这个变化。`1` 的影响太小，它在浮点数的表示中被舍掉了。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。

#### 浮点型精度误差
在 **IEEE 754 标准**中，浮点数是由 **符号位**、**指数** 和 **尾数** 组成的。虽然这种表示方式允许我们用较少的存储空间来表示非常大的数和非常小的数，但它有一个缺点：**某些十进制小数无法被精确表示成二进制形式**。

例如：

- 十进制的 `0.1` 在二进制中是一个无限循环小数：`0.0001100110011001100110011...`。
- 计算机只能保留有限的位数，因此它只能存储 `0.1` 的近似值。

即使对于看似简单的浮点数 `1.0`，它在计算机内部存储时也会近似表示。因此，当你进行浮点数运算时，误差可能会累积，导致结果不完全等于期望值。在某些情况下，由于浮点数的存储误差，**`1.0`** 可能不会被精确地表示为真正的 `1.0`，而是非常接近 `1.0` 的一个值。例如：
- 如果 `1.0` 实际上被存储为 `0.9999999999999999`（略小于 `1.0`），那么 `1.0 - 1.0` 的结果可能会是一个非常小的数，而不是严格的 `0`。
浮点运算可能得到的结果是一个 **接近零的值**，但不是精确的零，其他数字的计算也是如此。


### bool 类型
C++将非零值解释为true，零值解释为false。
```cpp
bool is_ready = true;
```


### 类型转换
C++自动执行很多类型转换：
* 将一种算术类型的值赋给另一种算术类型的变量时，C++将堆值进行转换
* 表达式中包含不同的类型时，C++将对值进行转换
* 将参数传递给函数时，C++将对值进行转换

1. 初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量，值将会被转换为接收变量的类型。
```cpp
long so_long = 0.0;
short thirty = 1.0;
so_long = thirty;
```
赋值时，程序将thirty的值扩展为long值。某些转换会带来问题：
![image.png|1025](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/15-34-42-59b7456a4e6aad30ca33af89f5c97733-20240919153440-226a3a.png)

将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会将数字截短（除掉小数部分）。其次， float 值对于 int 变量来说可能太大了。在这种情况下，C++并没有定义结果应该是什么；这意味着不同的实现的反应可能不同。

2. 表达式中的转换

当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。先来看看自动转换。在计算表达式时，C++将 bool、char、unsigned char、signed char 和 short 值转换为 int。具体地说，true 被转换为 1，false 被转换为 0。这些转换被称为整型提升（integral promotion）

```c
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
```

为执行第 3 行语句，C++程序取得 chickens 和 ducks 的值，并将它们转换为 int。然后，程序将结果转换为 short 类型，因为结果将被赋给一个 short 变量。

3. 传递参数时的转换
传递参数时的类型转换通常由 C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对 char 和 short 类型（signed 和 unsigned）应用整型提升。另外，为保持与传统 C 语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将 float 参数提升为 double。

4. 强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。
```c
(typeName) value;
typeName (value);
```

## 复合类型
### 数组
数组（array）是一种数据格式，能够存储多个同类型的值。要创建数组，可使用声明语句。数组声明应指出以下三点：
* 存储在每个元素中的值的类型； 
* 数组名； 
* 数组中的元素数。

声明数组的通用格式如下：
```c
typeName arrayName[arraySize];
```

表达式 arraySize 指定元素数目，它必须是整型常数（如 10）或 const 值，也可以是常量表达式（如 8 * sizeof（int）），即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。

数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从 0 开始编号（这没有商量的余地，必须从 0 开始。Pascal 和 BASIC 用户必须调整习惯）。 C++使用带索引的方括号表示法来指定数组元素。例如，months\[0]是 months 数组的第一个元素，months[11] 是最后一个元素。注意，最后一个元素的索引比数组长度小 1。因此，数组声明能够使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。

![image.png|800](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/16-10-27-2414f4ba86fdd20d390ed53de9388303-20240919161026-1a1d08.png)

C++允许在声明语句中初始化数组元素。
```c
int yamcosts[3] = {20,30,5};
```

需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。列表中的空格是可选的。如果没有初始化函数中定义的数组，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值。

将 sizeof 运算符用于数组名，得到的将是整个数组中的字节数。但如果将 sizeof 用于数组元素，则得到的将是元素的长度 （单位为字节）。这表明 yams 是一个数组，而 yams[1]只是一个 int 变量。

### 字符串
存储在连续字节中的一系列字符意味着可以将字符串存储在 char 数组中，其中每个字符都位于自己的数组元素中。
```c
char bird[11] = "Mr. Cheeps";
char fish[] = "Bubbles";
```

用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它另外，各种C++输入工具通过键盘输入，将字符串读入到 char 数组中时，将自动加上结尾的空字符。当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/22-34-43-af0c3e285dcb0b215eaa43428b70f8f6-20240919223443-7364f9.png)

#### 字符串拼接
时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。因此，下面所有的输出语句都是等效的：

```cpp
cout << "hello " " world";
cout << "hello world";
cout << "hello "
"world";
```

#### 在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种 — 将数组初始化为字符串常量、将键盘或文件输入读入到数组中。

```c
char name1[Size];
char name2[Size] = "C++owboy";
cin >> name1;
```

#### 字符串输入
cin 使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着 cin 在获取字符数组输入时只读取一个单词。读取该单词后，cin 将该字符串放到数组中，并自动在结尾添加空字符。\

#### 每次读取一行字符串输入
* getline( )
getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用 cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为 20，则函数最多读取 19 个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

```c
cin.getline(name,20);
```

* get( )
istream 类有另一个名为 get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与 getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 并不再读取并丢弃换行符，而是将其留在输入队列中。

```c
cin.get(name,ArSize);
cin.get(dessert,Arsize);
```

由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此 get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。幸运的是，get( )有另一种变体。使用不带任何参数的 cin.get( )调用可读取下一个字符（即使是换行符）， 因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：

```c
cin.get(name,ArSize);
cin.get();
cin.get(dessert,Arsize);
```

当 getline( )或 get( )读取空行时，下一条输入语句将在前一条 getline( ) 或 get( )结束读取的位置开始读取；但当前的做法是，当 get( )（不是 getline( )）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：
```c
cin.clear();
```

另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 getline( )和 get( )将把余下的字符留在输入队列中，而 getline( )还会设置失效位，并关闭后面的输入。


### String 类
ISO/ANSI C++98 标准通过添加 string 类扩展了 C++库，因此现在可以 string 类型的变量（使用 C++的话说是对象）而不是字符数组来存储字符串。
要使用 string 类，必须在程序中包含头文件 string。string 类位于名称空间 std 中，因此必须提供一条 using 编译指令，或者使用 std::string 来引用它。
```c
using namespace std;
char charr1[20];
char charr2[20] = "jaguar";
string str1;
string str2 = "panther";

cin >> charr1;
cout << charr1; 
```

#### C++11 字符串初始化
```c
string str2 = "panther";
```


#### 赋值、拼接和附加
可以将一个 string 对象赋给另一个 string 对象：
```c
string str1;
string str2 = "panther";
str1 = str2;
```

string 类简化了字符串合并操作。可以使用运算符+将两个 string 对象合并起来，还可以使用运算符+= 将字符串附加到 string 对象的末尾。
```c
string str3;
str3 = str1 + str2;
str1 += str2;
```

#### string 类 I/O
```c
cin.getline(charr,20);
```
这种句点表示法表明，函数 getline( )是 istream 类的一个类方法（还记得吗，cin 是一个 istream 对象）。正如前面指出的，第一个参数是目标数组；第二个参数数组长度，getline( )使用它来避免超越数组的边界。

```c
getline(cin,str);
```

这里没有使用句点表示法，这表明这个 getline( )不是类方法。它将 cin 作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度的参数，因为 string 对象将根据字符串的长度自动调整自己的大小。


### 结构体
#### 建立结构声明
结构声明（structure declaration）描述了一个结构的组织布局。
```c
struct book { 
	char title[MAXTITL]; 
	char author[MAXAUTL]; 
	float value; 
};
```
该声明描述了一个由两个字符数组和一个float类型变量组成的结构。该声明并未创建实际的数据对象，只描述了该对象由什么组成。关键字 struct，它表明跟在其后的是一个结构，后面是一个可选的标记。
在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用自己的声明来描述。成员可以是任意一种C的数据类型，甚至可以是其他结构！右花括号后面的分号是声明所必需的，表示结构布局定义结束。可以把这个声明放在所有函数的外部（如本例所示），也可以放在一个函数定义的内部。如果把结构声明置于一个函数的内部，它的标记就只限于该函数内部使用。如果把结构声明置于函数的外部，那么该声明之后的所有函数都能使用它的标记。
#### 定义结构体变量
在 C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在 C++中，省略 struct 不会出错。
```c
book library;
```

编译器执行这行代码便创建了一个结构变量library。编译器使用book模板为该变量分配空间：一个内含MAXTITL个元素的char数组、一个内含 MAXAUTL个元素的char数组和一个float类型的变量。这些存储空间都与一个名称library结合在一起。
![image.png|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/17/10-26-13-48fa160cdbcbbb6b89e5ca327f31d8d3-20240917102612-b42fa7.png)
#### 初始化结构
与数组一样，C++11 也支持将列表初始化用于结构，且等号（=）是可选的：
```c
book library{ 
	"The Pious Pirate and the Devious Damsel", 
	"Renee Vivotte", 
	1.95 
};
```
在一对花括号中括起来的初始化列表进行初始化， 各初始化项用逗号分隔。因此， title成员可以被初始化为一个字符串，value 成员可以被初始化为一个数字。为了让初始化项与结构中各成员的关联更加明显，我们让每个成员的初始化项独占一行。这样做只是为了提高代码的可读性，对编译器而言，只需要用逗号分隔各成员的初始化项即可。

其次，如果大括号内未包含任何东西，各个成员都将被设置为零。
```c
book library{ 
};

```

#### 结构体内存对齐


对齐规则：
1. 第一个成员在与结构体变量偏移量为0的地址处。（即结构体的首地址处，即对齐到0处）
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
3. 结构体的总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4. 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数

使用`#pragma pack(2)`可以规定系统默认对齐大小，需要与结构体中最大字节比较，较小的一个为对齐数
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/17/10-48-37-c6dfe3f75ad7d2c6d47904f8ac1eeca4-20240917104836-851baf.png)


#### 访问结构成员
使用结构成员运算符——点（.）访问结构中的成员。例如，library.value即访问library的value 部分。可以像使用任何float类型变量那样使用library.value。


### 共用体
共用体（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。创建联合和创建结构的方式相同，需要一个联合模板和联合变量。
```c
union hold { 
	int digit; 
	double bigfl; 
	char letter; 
};
```
根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。
```c
union hold fit; // hold类型的联合变量 
union hold save[10]; // 内含10个联合变量的数组 
union hold * pu; // 指向hold类型联合变量的指针
```
第1个声明创建了一个单独的联合变量fit。编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是double类型的数据。在我们的系统中，double类型占64位，即8字节。第2个声明创建了一个数组save，内含10个元素，每个元素都是8字节。第3个声明创建了一个指针，该指针变量储存hold类型联合变量的地址。可以初始化联合。需要注意的是，联合只能储存一个值，这与结构不同。有 3 种初始化的方法：把一个联合初始化为另一个同类型的联合；初始化联合的第1个元素；或者根据C99标准，使用指定初始化器：
```c
union hold valA; valA.letter = 'R'; 
union hold valB = valA; // 用另一个联合来初始化 
union hold valC = {88}; // 初始化联合的digit 成员 
union hold valD = {.bigfl = 118.2}; // 指定初始化器
```
下面是联合的一些用法： 
```c
fit.digit = 23; //把 23 储存在 fit，占2字节 
fit.bigfl = 2.0; // 清除23，储存 2.0，占8字节 
fit.letter = 'h'; // 清除2.0，储存h
```
占1字节点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写代码时要注意当前储存在联合中的数据类型。

### 枚举
可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。
```c
enum spectrum {red, orange, yellow, green, blue, violet}; 
enum spectrum color;
```

第1个声明创建了spetrum作为标记名，允许把enum spetrum作为一个类型名使用。第2个声明使color作为该类型的变量。第1个声明中花括号内的标识符枚举了spectrum变量可能有的值。因此， color 可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。

```c
int c; 
color = blue; 
if (color == yellow)  
for (color = red; color <= violet; color++)
```

虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。
默认情况下，枚举列表中的常量都被赋予0、1、2等。在枚举声明中，可以为枚举常量指定整数值：
```c
enum levels {low = 100, medium = 500, high = 2000};
```

如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：
```c
enum feline {cat, lynx = 10, puma, tiger};
```
那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、 12。

### 指针和自由空间
指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing） 运算符，将其应用于指针，可以得到该地址处存储的值。
```c
int updates = 6;
int * p_updates;
p_updates = &updates;
```
![image.png|600](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/15-59-16-e0f23b571044afae43ce9a4584b0770e-20240920155915-8feb9d.png)

#### 声明和初始化指针
指针声明必须指定指针指向的数据的类型。
```c
int *p_updates;
```
这表明，* p_updates 的类型为 int。由于*运算符被用于指针，因此 p_updates 变量本身必须是指针。
![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/16-03-23-b09930889bbe8aa4d653f79e7148e656-20240920160323-5f0baa.png)

#### 指针的危险
创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。
```c
long * fellow;
*fellow = 223323;
```

上述代码没有将地址赋给 fellow。由于 fellow 没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储 223323 的地址。如果 fellow 的值碰巧为 1200，计算机将把数据放在地址 1200 上，即使这恰巧是程序代码的地址。fellow 指向的地方很可能并不是所要存储 223323 的地方。

## 内存管理 
### 作用域
* 块作用域
```c
{
    int x = 10;  // x 具有块作用域
    printf("%d\n", x);
}
// 在此处无法访问 x
```

* 文件作用域
在所有函数之外声明的变量具有文件作用域。它们从声明的点开始直到文件的末尾都是可见的。
```c
int global_variable = 5;  // 具有文件作用域

void function() {
    printf("%d\n", global_variable);  // 可以访问
}
```

* 函数原型作用域
在函数原型中声明的参数具有函数原型作用域。它们的作用域仅在函数原型声明内。
```c
int function(int a);  // a 的作用域仅限于此函数原型声明
```

作用域嵌套
作用域可以嵌套。在嵌套的作用域中，如果内层作用域和外层作用域都声明了同名的变量，内层作用域中的变量会遮蔽外层作用域中的变量。
```c
{
    int x = 5;  // 外层块中的 x
    {
        int x = 10;  // 内层块中的 x 遮蔽了外层的 x
        printf("%d\n", x);  // 输出 10
    }
    printf("%d\n", x);  // 输出 5
}

```

### 存储区域
1. 代码区--------主要存储程序代码指令，define定义的常量。

2. 数据区------主要存储全局变量（常量），静态变量（常量），常量字符串。

3. 栈区--------主要存储局部变量，栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但内存大小有限。

4. 堆区--------由malloc,calloc分配的内存区域，其生命周期由free决定。堆的内存大小是由程序员分配的，理论上可以占据系统中的所有内存。
![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/14-59-54-5bafc4ca2bc515e8da85a41acb4ebf35-20240916145953-9b7793.png)

![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/15-00-23-456e384562c065cd8aab21461f7aced3-20240916150022-bb499c.png)

### 变量的存储类别与生命周期
C 语言中的变量根据其存储类别可以分为以下几种，并且它们的作用域和生命周期有所不同：
* 自动变量
在函数内部或块内声明，没有使用 `static` 关键字修饰的变量就是自动变量。它们具有块作用域，并且在进入块时创建，在退出块时销毁。
```c
void function() {
    int auto_variable = 20;  // 自动变量
}
```

* 静态变量变量
使用 `static` 关键字声明的变量可以是静态局部变量或静态全局变量。
静态局部变量：在函数内部声明，具有块作用域，但生命周期从程序运行开始到程序结束。即使函数调用结束，其值仍然保留。
```c
void function() {
    static int static_local_variable = 0;  // 静态局部变量
    static_local_variable++;
    printf("%d\n", static_local_variable);
}
```

静态全局变量：在函数外部声明，使用 `static` 关键字修饰。具有文件作用域，但只能在声明它的文件中访问。
```c
static int static_global_variable = 100;  // 静态全局变量

void function() {
    printf("%d\n", static_global_variable);  // 可以访问
}

```

* 外部变量
在函数外部声明，没有使用 `static` 关键字修饰的变量就是外部变量。具有文件作用域，可以在多个文件中通过 `extern` 关键字声明后使用。

假设有两个文件：`file1.c` 和 `file2.c`
在 `file1.c` 中：
```c
int external_variable = 50;  // 外部变量

```
在 `file2.c` 中：
```c
extern int external_variable;  // 通过 extern 声明，可以使用 file1.c 中的 external_variable

void function() {
    printf("%d\n", external_variable);  // 可以访问并输出 50
}

```

### 内存分配
在运行阶段分配未命名的内存以存储值，在这种情况下，只能通过指针来访问内存。
告诉new需要为哪种数据类型分配内存，new将找到一个正确的内存块，并返回该内存块的地址。
```c
int *pn = new int;
```
new int 告诉程序，需要适合存储 int 的内存。new 运算符根据类型来确定需要多少字节的内存。然后， 它找到这样的内存，并返回其地址。接下来，将地址赋给 pn，pn 是被声明为指向 int 的指针。
为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下：
```c
typeName * pointer_name = new typeName;
```

需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。

 delete 运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用 delete 时，后面要加上指向内存块的指针（这些内存块最初是用 new 分配的）：

```c
int *pd = new int;

delete ps;
```

这将释放 ps 指向的内存，但不会删除指针 ps 本身。例如，可以将 ps 重新指向另一个新分配的内存块。一定要配对地使用 new 和 delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。

在 C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉 new 即可。必须在类型名后加上方括号，其中包含元素数目。

```c
int * psome = new int[10];
```

new 运算符返回第一个元素的地址。当程序使用完 new 分配的内存块时，应使用 delete 释放它们。然而，对于使用 new 创建的数组，应使用另一种格式的 delete 来释放：

```c
delete [] psome;
```

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意 delete 和指针之间的方括号。如果使用 new 时，不带方括号，则使用 delete 时，也不应带方括号。如果使用 new 时带方括号，则使用 delete 时也应带方括号。

对于第 1 个元素，可以使用 psome\[0]，而不是*psome；对于第 2 个元素，可以使用 psome\[1]，依此类推。
```c
double * p3 = new double[3];
p3[0] = 0.2
p3[1] = 0.5;
p3[2] = 0.8;

p3 = p3 + 1;
```
不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将 p3 加 1 的效果。表达式 p3[0] 现在 4 个字节，而将 p3 加 1 后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。情况确实如此。 pointer arithmetic）和 C++内部处理数组的方式。但将指针变量加 1 后，增加的量等于它指向的类型的字节数。 C++将数组名解释为地址。指的是数组的第 2 个值。

### 命名空间
在 C++中，名称可以是变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称相互冲突的可能性也将增加。使用多个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为 List、Tree 和 Node 的类，但定义的方式不兼容。用户可能希望使用一个库的 List 类，而使用另一个库的 Tree 类。这种冲突被称为名称空间问题。 C++标准提供了名称空间工具，以便更好地控制名称的作用域。

C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。

```cpp
namespace Jack{
	double pail;
	void fetch();
	int pal;
	struct Well {...};
}

namespace Jill{
	double bucket(double n){ ...}
	double fetch();
	int pal;
	struct Hill{...};

}
```

称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下， 在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域。
因此，Jack 中的 fetch 可以与 Jill 中的 fetch 共存，Jill 中的 Hill 可以与外部 Hill 共存。名称空间中的声明和定义规则同全局声明和定义规则相同。名称空间是开放的（open），即可以把名称加入到已有的名称空间中。例如，下面这条语句将名称 goose 添加到 Jill 中已有的名称列表中：

```c
namespace Jill{
	char * goose(const char*);
}
```

同样，原来的 Jack 名称空间为 fetch( )函数提供了原型。可以在该文件后面（或另外一个文件中）再次使用 Jack 名称空间来提供该函数的代码：
```cpp
namespace Jack{
	void fetch(){
		...
	}
}
```
当然，需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析运算符`::`， 使用名称空间来限定该名称：
```cpp
Jack::pail = 12.34;
Jill::Hill mole;
Jack::fetch();
```


using 声明由被限定的名称和它前面的关键字 using 组成
```cpp
using Jill::fetch;
```

using 声明将特定的名称添加到它所属的声明区域中。例如 main( )中的 using 声明 Jill::fetch 将 fetch 添加到 main( )定义的声明区域中。完成该声明后，便可以使用名称 fetch 代替 Jill::fetch。下面的代码段说明了这几点：
```cpp
using Jill::fetch;
int main(){
	cin << feth;
}
```

和其他局部变量一样，fetch 也将覆盖同名的全局变量。在函数的外面使用 using 声明时，将把名称添加到全局名称空间中： using 声明使一个名称可用，而 using 编译指令使所有的名称都可用。using 编译指令由名称空间名和它前面的关键字 using namespace 组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：
```cpp
using namespace std;
cin >> x;
```


## 语句
### 循环语句
#### while
while循环的通用形式如下：
```c
while ( expression ) 
statement
```

expression是值之间的比较，可以使用任何表达式。如果expression为真 （或者更一般地说，非零），执行 statement部分一次，然后再次判断 expression。在expression为假（0）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代（iteration）。

![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/20-47-21-87ef08400fd45928e5e9c0240066819d-20240915204721-176d1d.png)
while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index < 5)。该表达式是一个入口条件（entry condition），因为必须满足条件才能进入循环体。对于真值，非零数为真值，而零为假值。

```c
int n = 0; 
while (n++ < 3){
	printf("n is %d\n", n);
}
```

#### for
for语句使用3个表达式控制循环过程，分别用分号隔开。initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真 （或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。

```c
for ( initialize; test; update ) 
statement //在test为假或0之前，重复执行statement部分。
```

 关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。第1个表达式是初始化，只会在for循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于 NUMBER时），循环结束。第3个表达式执行更新，在每次循环结束时求值。程序清单6.10用这个表达式递增count 的值，更新计数。完整的for语句还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。

```c
int count; 
for (count = 1; count <= NUMBER; count++) 
	printf("Be my Valentine!\n");
```

![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/20-59-29-36df0a3380b0cb2b56817e439349c629-20240915205928-5049de.png)

#### do while
出口条件循环：do while while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。
下面是do while循环的通用形式： 
```c
do 
statement 
while ( expression );
```
 do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而for循环或while循环都是在执行循环体之前先执行测试条件。
![|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/21-49-19-381cb713b6bbf2b14f6042138bfe1e2a-20240915214919-273b49.png)

### 分支语句
#### if
```c
 if ( expression ) 
 statement
```
如果对expression求值为真（非0），则执行statement；否则，跳过 statement。与while循环一样，statement可以是一条简单语句或复合语句。if 语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x > y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行 statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。
![Uploading file...himsu]()

#### if else
简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。 C还提供了if else形式，可以在两条语句之间作选择。
```c
if ( expression ) 
	statement1
else 
	statement2
```
如果expression为真（非0），则执行statement1；如果expression为假或 0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。
![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/08-56-22-1bad2f8ff2943271206a0b6233dacd9e-20240916085621-3e9545.png)

#### else if
```c
if (score < 1000) 
	bonus = 0; 
else if (score < 1500) 
	bonus = 1; 
else if (score < 2000) 
	bonus = 2;
else
	...
```

如果程序中有许多if和else，else与离它最近的if匹配，除非最近的if被花括号括起来
![image.png|525](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-00-26-ac5bc199ec376e4ea8b621fd6cf5a91e-20240916090026-6420c6.png)

### 循环辅助
#### continue
3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-34-41-a72212e602af60aa24fbe561bf2f8347-20240916093441-caeffe.png)

#### break
程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。
![|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-35-34-3f2842cab17bcc62e84e42c5497d5cd7-20240916093534-63a16b.png)

### 多重选择
```c
switch ( 整型表达式) { 
case 常量1: 语句 <--可选 
case 常量2: 语句 <--可选 
default : <--可选语句 <--可选 
}
```
对紧跟在关键字 switch 后圆括号中的表达式求值。然后程序扫描标签列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否则，程序继续执行在switch后面的语句。
 switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式 （即，表达式中只包含整型常量）。不能用变量作为case标签。

![image.png|452](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-50-30-1126dfe1a370138b418883f0cb95bd47-20240916095029-b18384.png)
break让程序离开switch语句，跳至switch语句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开始执行到switch末尾。

## 函数
函数（function）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。

### 创建并使用简单函数
```c


void starbar(void) /* 定义函数 */ { 
	int count; 
	for (count = 1; count <= WIDTH; count++) 
		putchar('*'); 
	putchar('\n'); 
}
	

```

程序在3处使用了starbar标识符：函数原型（function prototype）告诉编译器函数starbar()的类型；函数调用（function call）表明在此处执行函数； 函数定义（function definition）明确地指定了函数要做什么。

原型：
```c
void starbar(void); /* 函数原型 */
```
圆括号表明starbar是一个函数名。第1个void是函数类型，void类型表明函数没有返回值。第2个void（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。

一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。对于starbar()函数而言，其签名是该函数没有返回值，没有参数。

程序把 starbar()原型置于 main()的前面。当然，也可以放在 main()里面的声明变量处。放在哪个位置都可以。在main()中，执行到下面的语句时调用了starbar()函数：

```c
startbar(); // 函数调用
```

是调用void类型函数的一种形式。当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling function）继续执行下一行

程序中strarbar()和main()的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束。注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()，而不是调用函数或声明函数原型。

这是定义starbar()，而不是调用函数或声明函数原型。程序把 starbar()和 main()放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define 和#include 指令也放入该文件。


![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/2024/09/21/19-32-01-ad01fcad24a3edf63ddcec039910c317-19-56-13-ad01fcad24a3edf63ddcec039910c317-20240920195613-28bb70-6ee3c7.png)

### 函数参数
```c
void show_n_char(char ch, int num);
```
行告知编译器show_n_char()使用两个参数ch和num，ch是char类型， num是int类型。这两个变量被称为形式参数（formal argument，但是最近的标准推荐使用formal parameter），简称形参。和定义在函数中变量一样，形式数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。
```c
show_n_char(SPACE, 12);
```
实际参数是空格字符和12。这两个值被赋给show_n_char()中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。
![image.png|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/2024/09/21/19-32-01-56aa5d171a84b526c1a5a4859f5da7eb-21-47-53-56aa5d171a84b526c1a5a4859f5da7eb-20240920214752-7a5372-f07ff0.png)

### 函数类型
声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。
```c
double klink(int a, int b);
```


### 使用return从函数中返回值
```c
int imin(int n, int m) {
	int min; 
	if (n < m) 
		min = n; 
	else min = m; 
	return min; 
}
```
关键字return后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量min的值。因为min是int类型的变量，所以imin()函数的类型也是int。变量min属于imin()函数私有，但是return语句把min的值传回了主调函数。下面这条语句的作用是把min的值赋给lesser:
```c
lesser = imin(n,m);
```

### 使用指针在函数间通信
```c
void interchange(int * u, int * v) { 
	int temp; 
	temp = *u; // temp获得 u 所指向对象的值 
	*u = *v; 
	*v = temp; 
}

interchange(&x, &y);
```

该函数传递的不是x和y的值，而是它们的地址。这意味着出现在 interchange()原型和定义中的形式参数u和v将把地址作为它们的值。因此， 应把它们声明为指针。由于x和y是整数，所以u和v是指向整数的指针，其声明如下：
```c
void interchange (int * u, int * v);
```

### 函数和数组
```cpp
int sum_arr(int * arr,int b);
int sum_arr(int arr[],int b);
```

在 C++中，当（且仅当） 用于函数头或函数原型中，int \*arr 和 int arr \[ ]的含义才是相同的。它们都意味着 arr 是一个 int 指针。然而，数组表示法（int arr\[ ]）提醒用户，arr 不仅指向 int，还指向 int 数组的第一个 int。

![image.png|575](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/21/19-49-03-bca61194eb9ccc1536d1bebe759b57e8-20240921194903-f8a17f.png)



###  内联函数
执行到函数调用指令时， 程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在 10 个不同的地方调用同一个内联函数，则该程序将包含该函数代码的 10 个副本。应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。
![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/21/19-51-50-7962bf7e844377114e54a46c940c0ab7-20240921195149-466e00.png)

要使用这项特性，必须采取下述措施之一： 在函数声明前加上关键字 inline； 在函数定义前加上关键字 inline。通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），因此不将其作为内联函数；而有些编译器没有启用或实现这种特性。

```cpp
inline double square(double x) { return x * x;}
```

inline 工具是 C++新增的特性。C 语言使用预处理器语句#define 来提供宏—内联代码的原始实现。
```c
#define SQUARE(X) X*X
```

上述示例只有第一个能正常工作。如果使用 C 语言的宏执行了类似函数的功能，应考虑将它们转换为 C++内联函数。

### 引用变量
C++新增了一种复合类型 —引用变量。引用是已定义的变量的别名（另一个名称）。例如，如果将 twain 作为 clement 变量的引用，则可以交替使用 twain 和 clement 来表示该变量。除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。\

#### 创建引用变量
```cpp
int rats;
int & rodents = rats;
```
必须在声明引用时将其初始化， 而不能像指针那样，先声明，再赋值。

#### 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对 C 语言的超越，C 语言只能按值传递。

![image.png|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/21/20-08-09-e4999de6b00a4e9059a590c0a397119d-20240921200809-3263a0.png)

```cpp
void swapr(int & a,int & b);
```

### 默认参数
默认参数指的是当函数调用中省略了实参时自动使用的一个值。例如，如果将 void wow（int n）设置成 n 有默认值为 1，则函数调用 wow( )相当于 wow（1）。这极大地提高了使用函数的灵活性。
```cpp
char * left(const char * str,int n = 1);
```

对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值

### 函数重载
函数重载的关键是函数的参数列表—也称为函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。

```cpp
double cube(double x);
double cube(double & x);
```

### 函数模板
现在的 C++编译器实现了 C++新增的一项特性—函数模板。函数模板是通用的函数描述，也就是说， 它们使用泛型来定义函数，其中的泛型可用具体的类型（如 int 或 double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的 ， 因此模板特性有时也被称为参数化类型 （parameterized types）。

```c
template <typename AnyType>
void Swap(AnyType &a,AnyType &b){
	AnyType temp;
	temp = a;
	a = b;
	b = temp;
}
```

第一行指出，要建立一个模板，并将类型命名为 AnyType。关键字 template 和 typename 是必需的，除非可以使用关键字 class 代替 typename。另外，必须使用尖括号。类型名可以任意选择（这里为 AnyType）， 只要遵守 C++命名规则即可；许多程序员都使用简单的名称，如 T。余下的代码描述了交换两个 AnyType 值的算法。模板并不创建任何函数，而只是告诉编译器如何定义函数。需要交换 int 的函数时，编译器将按模板模式创建这样的函数，并用 int 代替 AnyType。同样，需要交换 double 的函数时，编译器将按模板模式创建这样的函数，并用 double 代替 AnyType。

```c
template <typename T>  
void Swap(T &a,T &b);  
  
int main() {  
    int a = 1,b = 0;  
    Swap(a,b);  
    cout << a << b;  
    return 0;  
}  
  
template <typename T>  
void Swap(T &a,T &b){  
    T temp;  
    temp = a;  
    a = b;  
    b= temp;  
}
```


## 类和对象
类是一种将抽象转换为用户定义类型的 C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。一般来说，类规范由两个部分组成。
* 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。
* 类方法定义：描述如何实现类成员函数。
简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。

```cpp
class Stock{
	private:
		std::string company;
		long shares;
		double share_val;
		double total_val;
		void set_tot(){
			total_val = shares * share_val;
		}
	public:
		void acquire(const std::string & co,long n,double pr);
}
```

首先，C++关键字 class 指出这些代码定义了一个类设计（不同于在模板参数中，在这里，关键字 class 和 typename 不是同义词，不能使用 typename 代替 class）。这种语法指出，Stock 是这个新类的类型名。该声明让我们能够声明 Stock 类型的变量—— 称为对象或实例。
```cpp
Stock sally;
Stock solly;
```

###  访问控制
关键字 private 和 public 也是新的，它们描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（来访问对象的私有成员。例如，要修改 Stock 类的 shares 成员，只能通过 Stock 的成员函数。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++ 还提供了第三个访问控制关键字 protected。
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/22/15-52-53-c235907ce02fe50555e79b41204adcd2-20240922155251-a9e459.png)

类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，，也是一种封装。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明它。但由于隐藏数据是 OOP 主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无法从程序中调用这些函数。正如 Stock 声明所表明的，也可以把成员函数放在私有部分中。不能直接从程序中调用这种函数，但公有方法却可以使用它们。通常，程序员使用私有成员函数来处理不属于公有接口的实现细节。

### 实现类成员函数
成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征： 
* 定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类； 
* 类方法可以访问类的 private 组件。
首先，成员函数的函数头使用作用域运算符解析（::）来指出函数所属的类。例如，update( )成员函数的函数头如下：
```cpp
void Buffoon::update();
```

作用域解析运算符确定了方法定义对应的类的身份。我们说，标识符 update( )具有类作用域（class scope）。Stock 类的其他成员函数不必使用作用域解析运算符，就可以使用 update( )方法，这是因为它们属于同一个类，因此 update( )是可见的。
类方法的完整名称中包括类名。我们说，Stock::update( )是函数的限定名（qualified name）；而简单的 update( )是全名的缩写（非限定名，unqualified name），它只能在类作用域中使用。方法的第二个特点是，方法可以访问类的私有成员。

```cpp
std::cout << shares;
```

其定义位于类声明中的函数都将自动成为内联函数。

### 创建对象
```cpp
Stock kate,joe;
```

使用对象的成员函数。和使用结构成员一样，通过成员运算符：
```cpp
kate.show();
joe.show();
```

所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
![image.png|550](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/22/16-10-59-4ad8b20a81262ba013555656aed55c10-20240922161059-21464c.png)

### 类的构造函数和析构函数

类构造函数，专门用于构造新对象、将值赋给它们的数据成员。更准确地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。名称与类名相同。
```cpp
Stock::Stock(const string & co,long n,double pr);

Stock::Stock(const string & co,long n,double pr){
	company = co;
	if(n < 0){
		shares = 0;
	}

	set_tot();
}
```

C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显式地调用构造函数：
```cpp
Stock garment = Stock("Electroshock Games",18,19.0);
```
另一种方式是隐式地调用构造函数：
```cpp
Stock garment("Furry Mason",50,2.5);
```

每次创建类对象（甚至使用 new 动态分配内存）时，C++都使用类构造函数。下面是将构造函数与 new 一起使用的方法：
```cpp
Stock *pstock = new Stock("Electroshock Games",18,19.0);
```

无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。因此构造函数被用来创建对象，而不能通过对象来调用。

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则 C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。
```cpp
Stock(){

}
```
默认构造函数没有参数，因为声明中不包含值。

用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用 new 来分配内存，则析构函数将使用 delete 来释放这些内存。Stock 的构造函数没有使用 new，因此析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可。
```cpp
Stock::~Strock(){

}
```
如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象（就像前面的示例中那样），则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过 new 创建的，则它将驻留在栈内存或自由存储区中，当使用 delete 来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。

### 列表初始化
```cpp
Strock hot_tip = {"Derivatives Plus Plus",100,45.0};
Stock jocK{"Sport Age Storage,inc"};
```

### this指针
this 指针指向用来调用成员函数的对象（this 被作为隐藏参数传递给方法）。每个成员函数（包括构造函数和析构函数）都有一个 this 指针。this 指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式\*this。
![image.png|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/22/17-03-34-9dde013eb2ca4a8f71508d9413c86299-20240922170334-1c6124.png)
```cpp
const Stock & Stock::topval(const Stock & s) const{
	if(s.total_val > total_val){
		return s;
	}
	else{
		return *thsi;
	}
}
```
返回类型为引用意味着返回的是调用对象本身，而不是其副本。

### 类作用域
在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象。
```cpp
Stock sleeper("Exclusive Ore",100,0.25);
sleeper.show();
```

### 运算符重载
要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：
```cpp
operatorop(argument-list);
```
例如，operator +( )重载+运算符，operator *( )重载*运算符。op 必须是有效的 C++运算符，不能虚构一个新的符号。例如，不能有 operator@( )这样的函数，因为 C++中没有@运算符。然而，operator [ ]( )函数将重载[ ]运算符，因为[ ]是数组索引运算符。例如，假设有一个 Salesperson 类，并为它定义了一个 operator +( )成员函数，以重载+运算符，以便能够将两个 Saleperson 对象的销售额相加，则如果 district2、sid 和 sara 都是 Salesperson 类对象，便可以编写这样的等式：
```cpp
district2 = sid + sara;
```
operator +( )由 Time 对象调用的，它将第二个 Time 对象作为参数，并返回一个 Time 对象。
```cpp
Time Time::operator+(const Time &t) const;

Time Time::operator+(const Time &t) const{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sun.minutes %= 60;
	return sum;
}
```

将该方法命令为 operator +( )后，也可以使用运算符表示法：
```cpp
total = coding + fixing;
```

在运算符表示法中，运算符左侧的对象（这里为 coding） 是调用对象，运算符右边的对象（这里为 fixing）是作为参数被传递的对象。

