## 进入c++
```c
#include <iostream>  
using namespace std;  
  
int main() {  
    int carrots;  
    cin >> carrots;  
    cout << "Hello, World!" << endl;  
    return 0;  
}
```

包含以下元素：
* iostream：包含输入输出的多个定义
* using命名空间：不用使用std::cout 等
* cout输出和cin输入
* 换行符`endl`

##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

#### **整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = '/f'`
ASKII码表达方式: `char grade = 65`
八进制表达方式： `char grade = '\007'`
十六进制表达方式： `char grade = '\0x010'`

### 浮点型

|  数据类型  | 表达方式 | 存储大小 |
| :----: | :--: | :--: |
| float  |  f   |  32  |
| double |  f   |  64  |

存储结构：
浮点型先转成二进制数再使用科学计数法表达
例如：$-8.25=1000.01=-1.00001 * 2^{3}$

* 符号位为：1
* 指数位为：3+127=130=10000010 使用偏移法，+127解决负指数没有符号位存储的问题 范围为 `-126` 到 `127`（用偏移量127表示的范围是 `1` 到 `254`），`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`）。
* 尾数位为：00001，
则内存表示为：
![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/2024/09/19/14-50-54-6a9d287590962e528826adde6f945edd-11-48-32-6a9d287590962e528826adde6f945edd-20240914114831-bff660-de426b.png)
`float`用1位表示符号位，8位表示指数位，23位标识尾数位
`double`用1位表示符号位，8位表示指数位，23+32位标识尾数位

#### 单精度浮点数可表示的最大值：
为了求出单精度浮点数能表示的最大值，我们需要让指数和尾数都达到它们的最大值。

**1. 最大尾数**

尾数由 23 位表示，加上隐含的前导 `1`，最大尾数可以表示为：

$1.111…111(23 个 1)$

这个尾数表示的值是接近于 2 的值，即：

$1.111…111=2−2^{−23}$

**2. 最大指数**

8 位的指数位可以表示的范围是 `0` 到 `255`。但是，`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`），所以指数的有效范围是 `1` 到 `254`。

在偏移 127 的情况下，最大可表示的指数值为：

$254−127=127$

这意味着指数部分表示的最大值为 $2^{127}$。

**3. 计算最大浮点数值**

将最大指数和最大尾数带入公式：

$最大浮点数=(2−2^{−23})×2^{127}$

简化后，这个值非常接近于：

$最大浮点数≈2×2^{127}=2^{128}$

转换为十进制：

$2^{128}≈3.4028235×10^{38}$

因此，单精度浮点数的最大可表示值大约是 $**3.4 × 10^{38}**$。

#### 浮点型溢出

**浮点型的上溢：**
在单精度浮点数（32位）的情况下，结果超出可表示的最大值，通常会被处理为 `inf`。

**浮点型的下溢：**
当除以一个非常小的数或非常大的数时，会遇到 **下溢（underflow）** 的问题。在这种情况下，数值会进入 **非正规数（subnormal）** 的范围。

通常，浮点数是按照 **规范化**（normalized） 的形式表示的。规范化的浮点数必须是以1开头的二进制数，形式为：
$(−1)^{sign}×1.fraction×2^{exponent−127}$

**非正规数（subnormal number）**：当浮点数太小，以至于不能再用 `1.xxx` 这种形式表示时，指数达到最小值 `0`，并且尾数的格式变为 `0.xxx`。此时，浮点数的表示不再遵循规范化的形式，而是：
$(−1)^{sign}×0.fraction×2^{−126}$
这是为了能够表示比最小正常数更小的数值，但代价是**精度降低**，因为不再有隐含的 `1` 作为尾数的起点。

当我们将一个 **非常小** 的浮点数除以 2 时，指数部分应该减小。但如果这个数已经是最小指数（`-126`）的正常数，再继续将它除以 2，将导致数值小于能表示的最小正常数，这时浮点数进入了 **非正规数** 的区域。

**非正规数的行为**：非正规数的指数不再减小，指数保持为 `-126`，而是通过尾数的移位来减小数值。这意味着当我们将数除以2时，尾数部分的位会向右移，最右边的位会被丢弃，精度也因此降低。

例如：
假设最小的正常数是： 
$1.00000000000000000000000×2^{−126}$

将这个数除以 2 后，我们得到： 
$0.10000000000000000000000×2^{−126}$

因为尾数不再能表示 `1.0000...` 这种形式，而是 `0.1000...`，所以它变成了非正规数。
继续下溢：

如果我们继续将这个非正规数除以 2，尾数会进一步右移，最终所有的位会变成 `0`，结果是： $0.000000000000000000000002×2^{−126} = 0$

这就是下溢的最终结果——当尾数的精度已经不足，进一步的运算将导致数值接近或等于零。

#### **舍入误差：**
```c
#include <stdio.h> 
int main(void) { 
	float a,b; 
	b = 2.0e20 + 1.0; 
	a = b - 2.0e20; 
	printf("%f \n", a); return 0; 
}
```

当我们对一个非常大的数（如 `2.0e20`）加上一个非常小的数（如 `1`）时，**精度不足** 导致了计算误差。
- `2.0e20` 表示 `2 × 10^20`，它等于 **2后面跟着20个零**，即 `200000000000000000000`。
- 如果我们对 `2.0e20` 加上 `1`，从数学上来说，结果应该是 `200000000000000000001`。

但是，**问题在于浮点数精度的限制**。对于一个像 `2.0e20` 这么大的数，计算机只能存储前 6-7 位有效数字，后面的数字则被舍入。因此，当我们加 `1` 时，计算机没有足够的位数来存储这个变化。`1` 的影响太小，它在浮点数的表示中被舍掉了。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。

#### 浮点型精度误差
在 **IEEE 754 标准**中，浮点数是由 **符号位**、**指数** 和 **尾数** 组成的。虽然这种表示方式允许我们用较少的存储空间来表示非常大的数和非常小的数，但它有一个缺点：**某些十进制小数无法被精确表示成二进制形式**。

例如：

- 十进制的 `0.1` 在二进制中是一个无限循环小数：`0.0001100110011001100110011...`。
- 计算机只能保留有限的位数，因此它只能存储 `0.1` 的近似值。

即使对于看似简单的浮点数 `1.0`，它在计算机内部存储时也会近似表示。因此，当你进行浮点数运算时，误差可能会累积，导致结果不完全等于期望值。在某些情况下，由于浮点数的存储误差，**`1.0`** 可能不会被精确地表示为真正的 `1.0`，而是非常接近 `1.0` 的一个值。例如：
- 如果 `1.0` 实际上被存储为 `0.9999999999999999`（略小于 `1.0`），那么 `1.0 - 1.0` 的结果可能会是一个非常小的数，而不是严格的 `0`。
浮点运算可能得到的结果是一个 **接近零的值**，但不是精确的零，其他数字的计算也是如此。


### bool 类型
C++将非零值解释为true，零值解释为false。
```cpp
bool is_ready = true;
```


### 类型转换
C++自动执行很多类型转换：
* 将一种算术类型的值赋给另一种算术类型的变量时，C++将堆值进行转换
* 表达式中包含不同的类型时，C++将对值进行转换
* 将参数传递给函数时，C++将对值进行转换

1. 初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量，值将会被转换为接收变量的类型。
```cpp
long so_long = 0.0;
short thirty = 1.0;
so_long = thirty;
```
赋值时，程序将thirty的值扩展为long值。某些转换会带来问题：
![image.png|1025](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/15-34-42-59b7456a4e6aad30ca33af89f5c97733-20240919153440-226a3a.png)

将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会将数字截短（除掉小数部分）。其次， float 值对于 int 变量来说可能太大了。在这种情况下，C++并没有定义结果应该是什么；这意味着不同的实现的反应可能不同。

2. 表达式中的转换

当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。先来看看自动转换。在计算表达式时，C++将 bool、char、unsigned char、signed char 和 short 值转换为 int。具体地说，true 被转换为 1，false 被转换为 0。这些转换被称为整型提升（integral promotion）

```c
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
```

为执行第 3 行语句，C++程序取得 chickens 和 ducks 的值，并将它们转换为 int。然后，程序将结果转换为 short 类型，因为结果将被赋给一个 short 变量。

3. 传递参数时的转换
传递参数时的类型转换通常由 C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对 char 和 short 类型（signed 和 unsigned）应用整型提升。另外，为保持与传统 C 语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将 float 参数提升为 double。

4. 强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。
```c
(typeName) value;
typeName (value);
```

## 复合类型
### 数组
数组（array）是一种数据格式，能够存储多个同类型的值。要创建数组，可使用声明语句。数组声明应指出以下三点：
* 存储在每个元素中的值的类型； 
* 数组名； 
* 数组中的元素数。

声明数组的通用格式如下：
```c
typeName arrayName[arraySize];
```

表达式 arraySize 指定元素数目，它必须是整型常数（如 10）或 const 值，也可以是常量表达式（如 8 * sizeof（int）），即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。

数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从 0 开始编号（这没有商量的余地，必须从 0 开始。Pascal 和 BASIC 用户必须调整习惯）。 C++使用带索引的方括号表示法来指定数组元素。例如，months\[0]是 months 数组的第一个元素，months[11] 是最后一个元素。注意，最后一个元素的索引比数组长度小 1。因此，数组声明能够使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。

![image.png|800](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/16-10-27-2414f4ba86fdd20d390ed53de9388303-20240919161026-1a1d08.png)

C++允许在声明语句中初始化数组元素。
```c
int yamcosts[3] = {20,30,5};
```

需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。列表中的空格是可选的。如果没有初始化函数中定义的数组，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值。

将 sizeof 运算符用于数组名，得到的将是整个数组中的字节数。但如果将 sizeof 用于数组元素，则得到的将是元素的长度 （单位为字节）。这表明 yams 是一个数组，而 yams[1]只是一个 int 变量。

### 字符串
存储在连续字节中的一系列字符意味着可以将字符串存储在 char 数组中，其中每个字符都位于自己的数组元素中。
```c
char bird[11] = "Mr. Cheeps";
char fish[] = "Bubbles";
```

用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它另外，各种C++输入工具通过键盘输入，将字符串读入到 char 数组中时，将自动加上结尾的空字符。当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/22-34-43-af0c3e285dcb0b215eaa43428b70f8f6-20240919223443-7364f9.png)

#### 字符串拼接
