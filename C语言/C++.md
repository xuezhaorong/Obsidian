## 进入c++
```c
#include <iostream>  
using namespace std;  
  
int main() {  
    int carrots;  
    cin >> carrots;  
    cout << "Hello, World!" << endl;  
    return 0;  
}
```

包含以下元素：
* iostream：包含输入输出的多个定义
* using命名空间：不用使用std::cout 等
* cout输出和cin输入
* 换行符`endl`

##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

#### **整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = '/f'`
ASKII码表达方式: `char grade = 65`
八进制表达方式： `char grade = '\007'`
十六进制表达方式： `char grade = '\0x010'`

### 浮点型

|  数据类型  | 表达方式 | 存储大小 |
| :----: | :--: | :--: |
| float  |  f   |  32  |
| double |  f   |  64  |

存储结构：
浮点型先转成二进制数再使用科学计数法表达
例如：$-8.25=1000.01=-1.00001 * 2^{3}$

* 符号位为：1
* 指数位为：3+127=130=10000010 使用偏移法，+127解决负指数没有符号位存储的问题 范围为 `-126` 到 `127`（用偏移量127表示的范围是 `1` 到 `254`），`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`）。
* 尾数位为：00001，
则内存表示为：
![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/2024/09/19/14-50-54-6a9d287590962e528826adde6f945edd-11-48-32-6a9d287590962e528826adde6f945edd-20240914114831-bff660-de426b.png)
`float`用1位表示符号位，8位表示指数位，23位标识尾数位
`double`用1位表示符号位，8位表示指数位，23+32位标识尾数位

#### 单精度浮点数可表示的最大值：
为了求出单精度浮点数能表示的最大值，我们需要让指数和尾数都达到它们的最大值。

**1. 最大尾数**

尾数由 23 位表示，加上隐含的前导 `1`，最大尾数可以表示为：

$1.111…111(23 个 1)$

这个尾数表示的值是接近于 2 的值，即：

$1.111…111=2−2^{−23}$

**2. 最大指数**

8 位的指数位可以表示的范围是 `0` 到 `255`。但是，`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`），所以指数的有效范围是 `1` 到 `254`。

在偏移 127 的情况下，最大可表示的指数值为：

$254−127=127$

这意味着指数部分表示的最大值为 $2^{127}$。

**3. 计算最大浮点数值**

将最大指数和最大尾数带入公式：

$最大浮点数=(2−2^{−23})×2^{127}$

简化后，这个值非常接近于：

$最大浮点数≈2×2^{127}=2^{128}$

转换为十进制：

$2^{128}≈3.4028235×10^{38}$

因此，单精度浮点数的最大可表示值大约是 $**3.4 × 10^{38}**$。

#### 浮点型溢出

**浮点型的上溢：**
在单精度浮点数（32位）的情况下，结果超出可表示的最大值，通常会被处理为 `inf`。

**浮点型的下溢：**
当除以一个非常小的数或非常大的数时，会遇到 **下溢（underflow）** 的问题。在这种情况下，数值会进入 **非正规数（subnormal）** 的范围。

通常，浮点数是按照 **规范化**（normalized） 的形式表示的。规范化的浮点数必须是以1开头的二进制数，形式为：
$(−1)^{sign}×1.fraction×2^{exponent−127}$

**非正规数（subnormal number）**：当浮点数太小，以至于不能再用 `1.xxx` 这种形式表示时，指数达到最小值 `0`，并且尾数的格式变为 `0.xxx`。此时，浮点数的表示不再遵循规范化的形式，而是：
$(−1)^{sign}×0.fraction×2^{−126}$
这是为了能够表示比最小正常数更小的数值，但代价是**精度降低**，因为不再有隐含的 `1` 作为尾数的起点。

当我们将一个 **非常小** 的浮点数除以 2 时，指数部分应该减小。但如果这个数已经是最小指数（`-126`）的正常数，再继续将它除以 2，将导致数值小于能表示的最小正常数，这时浮点数进入了 **非正规数** 的区域。

**非正规数的行为**：非正规数的指数不再减小，指数保持为 `-126`，而是通过尾数的移位来减小数值。这意味着当我们将数除以2时，尾数部分的位会向右移，最右边的位会被丢弃，精度也因此降低。

例如：
假设最小的正常数是： 
$1.00000000000000000000000×2^{−126}$

将这个数除以 2 后，我们得到： 
$0.10000000000000000000000×2^{−126}$

因为尾数不再能表示 `1.0000...` 这种形式，而是 `0.1000...`，所以它变成了非正规数。
继续下溢：

如果我们继续将这个非正规数除以 2，尾数会进一步右移，最终所有的位会变成 `0`，结果是： $0.000000000000000000000002×2^{−126} = 0$

这就是下溢的最终结果——当尾数的精度已经不足，进一步的运算将导致数值接近或等于零。

#### **舍入误差：**
```c
#include <stdio.h> 
int main(void) { 
	float a,b; 
	b = 2.0e20 + 1.0; 
	a = b - 2.0e20; 
	printf("%f \n", a); return 0; 
}
```

当我们对一个非常大的数（如 `2.0e20`）加上一个非常小的数（如 `1`）时，**精度不足** 导致了计算误差。
- `2.0e20` 表示 `2 × 10^20`，它等于 **2后面跟着20个零**，即 `200000000000000000000`。
- 如果我们对 `2.0e20` 加上 `1`，从数学上来说，结果应该是 `200000000000000000001`。

但是，**问题在于浮点数精度的限制**。对于一个像 `2.0e20` 这么大的数，计算机只能存储前 6-7 位有效数字，后面的数字则被舍入。因此，当我们加 `1` 时，计算机没有足够的位数来存储这个变化。`1` 的影响太小，它在浮点数的表示中被舍掉了。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。

#### 浮点型精度误差
在 **IEEE 754 标准**中，浮点数是由 **符号位**、**指数** 和 **尾数** 组成的。虽然这种表示方式允许我们用较少的存储空间来表示非常大的数和非常小的数，但它有一个缺点：**某些十进制小数无法被精确表示成二进制形式**。

例如：

- 十进制的 `0.1` 在二进制中是一个无限循环小数：`0.0001100110011001100110011...`。
- 计算机只能保留有限的位数，因此它只能存储 `0.1` 的近似值。

即使对于看似简单的浮点数 `1.0`，它在计算机内部存储时也会近似表示。因此，当你进行浮点数运算时，误差可能会累积，导致结果不完全等于期望值。在某些情况下，由于浮点数的存储误差，**`1.0`** 可能不会被精确地表示为真正的 `1.0`，而是非常接近 `1.0` 的一个值。例如：
- 如果 `1.0` 实际上被存储为 `0.9999999999999999`（略小于 `1.0`），那么 `1.0 - 1.0` 的结果可能会是一个非常小的数，而不是严格的 `0`。
浮点运算可能得到的结果是一个 **接近零的值**，但不是精确的零，其他数字的计算也是如此。


### bool 类型
C++将非零值解释为true，零值解释为false。
```cpp
bool is_ready = true;
```


### 类型转换
C++自动执行很多类型转换：
* 将一种算术类型的值赋给另一种算术类型的变量时，C++将堆值进行转换
* 表达式中包含不同的类型时，C++将对值进行转换
* 将参数传递给函数时，C++将对值进行转换

1. 初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量，值将会被转换为接收变量的类型。
```cpp
long so_long = 0.0;
short thirty = 1.0;
so_long = thirty;
```
赋值时，程序将thirty的值扩展为long值。某些转换会带来问题：
![image.png|1025](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/15-34-42-59b7456a4e6aad30ca33af89f5c97733-20240919153440-226a3a.png)

将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会将数字截短（除掉小数部分）。其次， float 值对于 int 变量来说可能太大了。在这种情况下，C++并没有定义结果应该是什么；这意味着不同的实现的反应可能不同。

2. 表达式中的转换

当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换：首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。先来看看自动转换。在计算表达式时，C++将 bool、char、unsigned char、signed char 和 short 值转换为 int。具体地说，true 被转换为 1，false 被转换为 0。这些转换被称为整型提升（integral promotion）

```c
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
```

为执行第 3 行语句，C++程序取得 chickens 和 ducks 的值，并将它们转换为 int。然后，程序将结果转换为 short 类型，因为结果将被赋给一个 short 变量。

3. 传递参数时的转换
传递参数时的类型转换通常由 C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对 char 和 short 类型（signed 和 unsigned）应用整型提升。另外，为保持与传统 C 语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将 float 参数提升为 double。

4. 强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。
```c
(typeName) value;
typeName (value);
```

## 复合类型
### 数组
数组（array）是一种数据格式，能够存储多个同类型的值。要创建数组，可使用声明语句。数组声明应指出以下三点：
* 存储在每个元素中的值的类型； 
* 数组名； 
* 数组中的元素数。

声明数组的通用格式如下：
```c
typeName arrayName[arraySize];
```

表达式 arraySize 指定元素数目，它必须是整型常数（如 10）或 const 值，也可以是常量表达式（如 8 * sizeof（int）），即其中所有的值在编译时都是已知的。具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。

数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从 0 开始编号（这没有商量的余地，必须从 0 开始。Pascal 和 BASIC 用户必须调整习惯）。 C++使用带索引的方括号表示法来指定数组元素。例如，months\[0]是 months 数组的第一个元素，months[11] 是最后一个元素。注意，最后一个元素的索引比数组长度小 1。因此，数组声明能够使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。

![image.png|800](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/16-10-27-2414f4ba86fdd20d390ed53de9388303-20240919161026-1a1d08.png)

C++允许在声明语句中初始化数组元素。
```c
int yamcosts[3] = {20,30,5};
```

需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。列表中的空格是可选的。如果没有初始化函数中定义的数组，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值。

将 sizeof 运算符用于数组名，得到的将是整个数组中的字节数。但如果将 sizeof 用于数组元素，则得到的将是元素的长度 （单位为字节）。这表明 yams 是一个数组，而 yams[1]只是一个 int 变量。

### 字符串
存储在连续字节中的一系列字符意味着可以将字符串存储在 char 数组中，其中每个字符都位于自己的数组元素中。
```c
char bird[11] = "Mr. Cheeps";
char fish[] = "Bubbles";
```

用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它另外，各种C++输入工具通过键盘输入，将字符串读入到 char 数组中时，将自动加上结尾的空字符。当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/19/22-34-43-af0c3e285dcb0b215eaa43428b70f8f6-20240919223443-7364f9.png)

#### 字符串拼接
时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。因此，下面所有的输出语句都是等效的：

```cpp
cout << "hello " " world";
cout << "hello world";
cout << "hello "
"world";
```

#### 在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种 — 将数组初始化为字符串常量、将键盘或文件输入读入到数组中。

```c
char name1[Size];
char name2[Size] = "C++owboy";
cin >> name1;
```

#### 字符串输入
cin 使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着 cin 在获取字符数组输入时只读取一个单词。读取该单词后，cin 将该字符串放到数组中，并自动在结尾添加空字符。\

#### 每次读取一行字符串输入
* getline( )
getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用 cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为 20，则函数最多读取 19 个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

```c
cin.getline(name,20);
```

* get( )
istream 类有另一个名为 get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与 getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 并不再读取并丢弃换行符，而是将其留在输入队列中。

```c
cin.get(name,ArSize);
cin.get(dessert,Arsize);
```

由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此 get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。幸运的是，get( )有另一种变体。使用不带任何参数的 cin.get( )调用可读取下一个字符（即使是换行符）， 因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：

```c
cin.get(name,ArSize);
cin.get();
cin.get(dessert,Arsize);
```

当 getline( )或 get( )读取空行时，下一条输入语句将在前一条 getline( ) 或 get( )结束读取的位置开始读取；但当前的做法是，当 get( )（不是 getline( )）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：
```c
cin.clear();
```

另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 getline( )和 get( )将把余下的字符留在输入队列中，而 getline( )还会设置失效位，并关闭后面的输入。


## String 类
ISO/ANSI C++98 标准通过添加 string 类扩展了 C++库，因此现在可以 string 类型的变量（使用 C++的话说是对象）而不是字符数组来存储字符串。
要使用 string 类，必须在程序中包含头文件 string。string 类位于名称空间 std 中，因此必须提供一条 using 编译指令，或者使用 std::string 来引用它。
```c
using namespace std;
char charr1[20];
char charr2[20] = "jaguar";
string str1;
string str2 = "panther";

cin >> charr1;
cout << charr1; 
```

#### C++11 字符串初始化
```c
string str2 = "panther";
```


#### 赋值、拼接和附加
可以将一个 string 对象赋给另一个 string 对象：
```c
string str1;
string str2 = "panther";
str1 = str2;
```

string 类简化了字符串合并操作。可以使用运算符+将两个 string 对象合并起来，还可以使用运算符+= 将字符串附加到 string 对象的末尾。
```c
string str3;
str3 = str1 + str2;
str1 += str2;
```

#### string 类 I/O
```c
cin.getline(charr,20);
```
这种句点表示法表明，函数 getline( )是 istream 类的一个类方法（还记得吗，cin 是一个 istream 对象）。正如前面指出的，第一个参数是目标数组；第二个参数数组长度，getline( )使用它来避免超越数组的边界。

```c
getline(cin,str);
```

这里没有使用句点表示法，这表明这个 getline( )不是类方法。它将 cin 作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度的参数，因为 string 对象将根据字符串的长度自动调整自己的大小。


### 结构体
#### 建立结构声明
结构声明（structure declaration）描述了一个结构的组织布局。
```c
struct book { 
	char title[MAXTITL]; 
	char author[MAXAUTL]; 
	float value; 
};
```
该声明描述了一个由两个字符数组和一个float类型变量组成的结构。该声明并未创建实际的数据对象，只描述了该对象由什么组成。关键字 struct，它表明跟在其后的是一个结构，后面是一个可选的标记。
在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用自己的声明来描述。成员可以是任意一种C的数据类型，甚至可以是其他结构！右花括号后面的分号是声明所必需的，表示结构布局定义结束。可以把这个声明放在所有函数的外部（如本例所示），也可以放在一个函数定义的内部。如果把结构声明置于一个函数的内部，它的标记就只限于该函数内部使用。如果把结构声明置于函数的外部，那么该声明之后的所有函数都能使用它的标记。
#### 定义结构体变量
在 C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在 C++中，省略 struct 不会出错。
```c
book library;
```

编译器执行这行代码便创建了一个结构变量library。编译器使用book模板为该变量分配空间：一个内含MAXTITL个元素的char数组、一个内含 MAXAUTL个元素的char数组和一个float类型的变量。这些存储空间都与一个名称library结合在一起。
![image.png|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/17/10-26-13-48fa160cdbcbbb6b89e5ca327f31d8d3-20240917102612-b42fa7.png)
#### 初始化结构
与数组一样，C++11 也支持将列表初始化用于结构，且等号（=）是可选的：
```c
book library{ 
	"The Pious Pirate and the Devious Damsel", 
	"Renee Vivotte", 
	1.95 
};
```
在一对花括号中括起来的初始化列表进行初始化， 各初始化项用逗号分隔。因此， title成员可以被初始化为一个字符串，value 成员可以被初始化为一个数字。为了让初始化项与结构中各成员的关联更加明显，我们让每个成员的初始化项独占一行。这样做只是为了提高代码的可读性，对编译器而言，只需要用逗号分隔各成员的初始化项即可。

其次，如果大括号内未包含任何东西，各个成员都将被设置为零。
```c
book library{ 
};

```

#### 结构体内存对齐


对齐规则：
1. 第一个成员在与结构体变量偏移量为0的地址处。（即结构体的首地址处，即对齐到0处）
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
3. 结构体的总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4. 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数

使用`#pragma pack(2)`可以规定系统默认对齐大小，需要与结构体中最大字节比较，较小的一个为对齐数
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/17/10-48-37-c6dfe3f75ad7d2c6d47904f8ac1eeca4-20240917104836-851baf.png)


#### 访问结构成员
使用结构成员运算符——点（.）访问结构中的成员。例如，library.value即访问library的value 部分。可以像使用任何float类型变量那样使用library.value。


### 共用体
共用体（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。创建联合和创建结构的方式相同，需要一个联合模板和联合变量。
```c
union hold { 
	int digit; 
	double bigfl; 
	char letter; 
};
```
根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。
```c
union hold fit; // hold类型的联合变量 
union hold save[10]; // 内含10个联合变量的数组 
union hold * pu; // 指向hold类型联合变量的指针
```
第1个声明创建了一个单独的联合变量fit。编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是double类型的数据。在我们的系统中，double类型占64位，即8字节。第2个声明创建了一个数组save，内含10个元素，每个元素都是8字节。第3个声明创建了一个指针，该指针变量储存hold类型联合变量的地址。可以初始化联合。需要注意的是，联合只能储存一个值，这与结构不同。有 3 种初始化的方法：把一个联合初始化为另一个同类型的联合；初始化联合的第1个元素；或者根据C99标准，使用指定初始化器：
```c
union hold valA; valA.letter = 'R'; 
union hold valB = valA; // 用另一个联合来初始化 
union hold valC = {88}; // 初始化联合的digit 成员 
union hold valD = {.bigfl = 118.2}; // 指定初始化器
```
下面是联合的一些用法： 
```c
fit.digit = 23; //把 23 储存在 fit，占2字节 
fit.bigfl = 2.0; // 清除23，储存 2.0，占8字节 
fit.letter = 'h'; // 清除2.0，储存h
```
占1字节点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写代码时要注意当前储存在联合中的数据类型。

### 枚举
可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。
```c
enum spectrum {red, orange, yellow, green, blue, violet}; 
enum spectrum color;
```

第1个声明创建了spetrum作为标记名，允许把enum spetrum作为一个类型名使用。第2个声明使color作为该类型的变量。第1个声明中花括号内的标识符枚举了spectrum变量可能有的值。因此， color 可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。

```c
int c; 
color = blue; 
if (color == yellow)  
for (color = red; color <= violet; color++)
```

虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。
默认情况下，枚举列表中的常量都被赋予0、1、2等。在枚举声明中，可以为枚举常量指定整数值：
```c
enum levels {low = 100, medium = 500, high = 2000};
```

如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：
```c
enum feline {cat, lynx = 10, puma, tiger};
```
那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、 12。

### 指针和自由空间
指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing） 运算符，将其应用于指针，可以得到该地址处存储的值。
```c
int updates = 6;
int * p_updates;
p_updates = &updates;
```
![image.png|600](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/15-59-16-e0f23b571044afae43ce9a4584b0770e-20240920155915-8feb9d.png)

#### 声明和初始化指针
指针声明必须指定指针指向的数据的类型。
```c
int *p_updates;
```
这表明，* p_updates 的类型为 int。由于*运算符被用于指针，因此 p_updates 变量本身必须是指针。
![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/20/16-03-23-b09930889bbe8aa4d653f79e7148e656-20240920160323-5f0baa.png)

#### 指针的危险
创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。
```c
long * fellow;
*fellow = 223323;
```

上述代码没有将地址赋给 fellow。由于 fellow 没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储 223323 的地址。如果 fellow 的值碰巧为 1200，计算机将把数据放在地址 1200 上，即使这恰巧是程序代码的地址。fellow 指向的地方很可能并不是所要存储 223323 的地方。

## 内存管理 

### 内存分配
在运行阶段分配未命名的内存以存储值，在这种情况下，只能通过指针来访问内存。
告诉new需要为哪种数据类型分配内存，new将找到一个正确的内存块，并返回该内存块的地址。
```c
int *pn = new int;
```
new int 告诉程序，需要适合存储 int 的内存。new 运算符根据类型来确定需要多少字节的内存。然后， 它找到这样的内存，并返回其地址。接下来，将地址赋给 pn，pn 是被声明为指向 int 的指针。
为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下：
```c
typeName * pointer_name = new typeName;
```

需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。

 delete 运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用 delete 时，后面要加上指向内存块的指针（这些内存块最初是用 new 分配的）：

```c
int *pd = new int;

delete ps;
```

这将释放 ps 指向的内存，但不会删除指针 ps 本身。例如，可以将 ps 重新指向另一个新分配的内存块。一定要配对地使用 new 和 delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。

在 C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉 new 即可。必须在类型名后加上方括号，其中包含元素数目。

```c
int * psome = new int[10];
```

new 运算符返回第一个元素的地址。当程序使用完 new 分配的内存块时，应使用 delete 释放它们。然而，对于使用 new 创建的数组，应使用另一种格式的 delete 来释放：

```c
delete [] psome;
```

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意 delete 和指针之间的方括号。如果使用 new 时，不带方括号，则使用 delete 时，也不应带方括号。如果使用 new 时带方括号，则使用 delete 时也应带方括号。

对于第 1 个元素，可以使用 psome\[0]，而不是*psome；对于第 2 个元素，可以使用 psome\[1]，依此类推。
```c
double * p3 = new double[3];
p3[0] = 0.2
p3[1] = 0.5;
p3[2] = 0.8;

p3 = p3 + 1;
```
不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将 p3 加 1 的效果。表达式 p3[0] 现在 4 个字节，而将 p3 加 1 后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。情况确实如此。 pointer arithmetic）和 C++内部处理数组的方式。但将指针变量加 1 后，增加的量等于它指向的类型的字节数。 C++将数组名解释为地址。指的是数组的第 2 个值。