下面是do while循环的通用形式： do statement while ( expression );##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

#### **整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = '/f'`
ASKII码表达方式: `char grade = 65`
八进制表达方式： `char grade = '\007'`
十六进制表达方式： `char grade = '\0x010'`

### 浮点型

|  数据类型  | 表达方式 | 存储大小 |
| :----: | :--: | :--: |
| float  |  f   |  32  |
| double |  f   |  64  |

存储结构：
浮点型先转成二进制数再使用科学计数法表达
例如：$-8.25=1000.01=-1.00001 * 2^{3}$

* 符号位为：1
* 指数位为：3+127=130=10000010 使用偏移法，+127解决负指数没有符号位存储的问题 范围为 `-126` 到 `127`（用偏移量127表示的范围是 `1` 到 `254`），`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`）。
* 尾数位为：00001，
则内存表示为：
![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/11-48-32-6a9d287590962e528826adde6f945edd-20240914114831-bff660.png)
`float`用1位表示符号位，8位表示指数位，23位标识尾数位
`double`用1位表示符号位，8位表示指数位，23+32位标识尾数位

#### 单精度浮点数可表示的最大值：
为了求出单精度浮点数能表示的最大值，我们需要让指数和尾数都达到它们的最大值。

**1. 最大尾数**

尾数由 23 位表示，加上隐含的前导 `1`，最大尾数可以表示为：

$1.111…111(23 个 1)$

这个尾数表示的值是接近于 2 的值，即：

$1.111…111=2−2^{−23}$

**2. 最大指数**

8 位的指数位可以表示的范围是 `0` 到 `255`。但是，`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`），所以指数的有效范围是 `1` 到 `254`。

在偏移 127 的情况下，最大可表示的指数值为：

$254−127=127$

这意味着指数部分表示的最大值为 $2^{127}$。

**3. 计算最大浮点数值**

将最大指数和最大尾数带入公式：

$最大浮点数=(2−2^{−23})×2^{127}$

简化后，这个值非常接近于：

$最大浮点数≈2×2^{127}=2^{128}$

转换为十进制：

$2^{128}≈3.4028235×10^{38}$

因此，单精度浮点数的最大可表示值大约是 $**3.4 × 10^{38}**$。

#### 浮点型溢出

**浮点型的上溢：**
在单精度浮点数（32位）的情况下，结果超出可表示的最大值，通常会被处理为 `inf`。

**浮点型的下溢：**
当除以一个非常小的数或非常大的数时，会遇到 **下溢（underflow）** 的问题。在这种情况下，数值会进入 **非正规数（subnormal）** 的范围。

通常，浮点数是按照 **规范化**（normalized） 的形式表示的。规范化的浮点数必须是以1开头的二进制数，形式为：
$(−1)^{sign}×1.fraction×2^{exponent−127}$

**非正规数（subnormal number）**：当浮点数太小，以至于不能再用 `1.xxx` 这种形式表示时，指数达到最小值 `0`，并且尾数的格式变为 `0.xxx`。此时，浮点数的表示不再遵循规范化的形式，而是：
$(−1)^{sign}×0.fraction×2^{−126}$
这是为了能够表示比最小正常数更小的数值，但代价是**精度降低**，因为不再有隐含的 `1` 作为尾数的起点。

当我们将一个 **非常小** 的浮点数除以 2 时，指数部分应该减小。但如果这个数已经是最小指数（`-126`）的正常数，再继续将它除以 2，将导致数值小于能表示的最小正常数，这时浮点数进入了 **非正规数** 的区域。

**非正规数的行为**：非正规数的指数不再减小，指数保持为 `-126`，而是通过尾数的移位来减小数值。这意味着当我们将数除以2时，尾数部分的位会向右移，最右边的位会被丢弃，精度也因此降低。

例如：
假设最小的正常数是： 
$1.00000000000000000000000×2^{−126}$

将这个数除以 2 后，我们得到： 
$0.10000000000000000000000×2^{−126}$

因为尾数不再能表示 `1.0000...` 这种形式，而是 `0.1000...`，所以它变成了非正规数。
继续下溢：

如果我们继续将这个非正规数除以 2，尾数会进一步右移，最终所有的位会变成 `0`，结果是： $0.000000000000000000000002×2^{−126} = 0$

这就是下溢的最终结果——当尾数的精度已经不足，进一步的运算将导致数值接近或等于零。

#### **舍入误差：**
```c
#include <stdio.h> 
int main(void) { 
	float a,b; 
	b = 2.0e20 + 1.0; 
	a = b - 2.0e20; 
	printf("%f \n", a); return 0; 
}
```

当我们对一个非常大的数（如 `2.0e20`）加上一个非常小的数（如 `1`）时，**精度不足** 导致了计算误差。
- `2.0e20` 表示 `2 × 10^20`，它等于 **2后面跟着20个零**，即 `200000000000000000000`。
- 如果我们对 `2.0e20` 加上 `1`，从数学上来说，结果应该是 `200000000000000000001`。

但是，**问题在于浮点数精度的限制**。对于一个像 `2.0e20` 这么大的数，计算机只能存储前 6-7 位有效数字，后面的数字则被舍入。因此，当我们加 `1` 时，计算机没有足够的位数来存储这个变化。`1` 的影响太小，它在浮点数的表示中被舍掉了。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。

#### 浮点型精度误差
在 **IEEE 754 标准**中，浮点数是由 **符号位**、**指数** 和 **尾数** 组成的。虽然这种表示方式允许我们用较少的存储空间来表示非常大的数和非常小的数，但它有一个缺点：**某些十进制小数无法被精确表示成二进制形式**。

例如：

- 十进制的 `0.1` 在二进制中是一个无限循环小数：`0.0001100110011001100110011...`。
- 计算机只能保留有限的位数，因此它只能存储 `0.1` 的近似值。

即使对于看似简单的浮点数 `1.0`，它在计算机内部存储时也会近似表示。因此，当你进行浮点数运算时，误差可能会累积，导致结果不完全等于期望值。在某些情况下，由于浮点数的存储误差，**`1.0`** 可能不会被精确地表示为真正的 `1.0`，而是非常接近 `1.0` 的一个值。例如：
- 如果 `1.0` 实际上被存储为 `0.9999999999999999`（略小于 `1.0`），那么 `1.0 - 1.0` 的结果可能会是一个非常小的数，而不是严格的 `0`。
浮点运算可能得到的结果是一个 **接近零的值**，但不是精确的零，其他数字的计算也是如此。

#### 类型转换
* 自动转换机制：
1. 当类型转换出现在表达式时，无论是unsigned还是signed的char和short 都会被自动转换成int，如有必要会被转换成unsigned int（如果short与int的大小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成 unsigned int）。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。
4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。 
5. 当作为函数参数传递时，char和short被转换成int，float被转换成 double。

* 强制转换机制：
```c
mice = 1.6 + 1.7; 
mice = (int)1.6 + (int)1.7;
```

第1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配 int 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。

## 内存管理 


## 字符串
### 字符串
```c
#include <string.h>
int main(){
	char name[40];
	scanf("%s:",&name);
	return 0;
}
```
字符串（character string）是一个或多个字符的序列，字符串都被储存在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。
![image.png|775](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-41-56-de21d566e36ed83fafba7a5b8c7c7ddc-20240914144155-3b953b.png)
数组末尾位置的字符\0。这是空字符（null character），C 语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII 码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。

使用双引号规定字符串，自动在末尾加入空字符。
#### strlen
```c
unsigned long length = strlen(name);
```
strlen() 函数给出字符串中的字符长度，不计入最后的空字符。
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-46-58-d16cd6e11b821b13d7e28398808936ab-20240914144657-a61062.png)

## 输入输出
### 缓冲区
大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。
![image.png|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/11-12-48-5dd6730c29e872d115b35dcb06f0b5fb-20240916111247-c64f8a.png)

缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。

### 流处理
C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、 printf()和scanf()函数都是标准I/O包的成员，处理这两个流。
概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。

### 单字符I/O

#### getchar()
`getchar()`函数不带任何参数，它从输入队列中返回下一个字符。例如， 下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：
```c
char ch;
ch = getchar();
```

#### putchar()
`putchar()`函数将单个字符打印出来
```c
char ch;  
while ((ch = getchar()) != '#')  
    putchar(ch);  
return 0;
```

### 字符串IO
#### printf

printf()函数能让用户可以与程序交流，它输出函数，请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如， 打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明 （conversion specification），它们指定了如何把数据转换成可显示的形式。
![image.png|825](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-56-22-58b3266ec99c5ff07b500444dddee0ce-20240914145622-bbccab.png)

空参数问题：
```c
printf("%d,%hd",word);
```
输出：
```c
65618,21664
```

由于没有给第二个转换符号具体参数，所以打印出的值是内存中的任意值


##### 转换说明

| 数据类型     |     |
| -------- | --- |
| short    | %h  |
| int      | %d  |
| long     | %l  |
| unsigned | %u_ |
| 八进制      | %o  |
| 十六进制     | %x  |
| 字符串      | %s  |
| %        | %%  |

**转换不匹配问题：**
* 有符号与无符号
```c
short num = 336;
printf("%hd,%hu",num,num);
```
输出：
` -336 65200`
系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534 表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解释成有符号int时，65200代表-336。

* 大字节与小字节
```c
int word = 65618;  
printf("%d,%hd",word,word);
```
输出：
`65618,82`

第二项使用了 `%hd`，它要求 `word` 被解释为 `short int`，即它会将 `word` 的低 16 位当作一个 `short int` 来处理。
`65618` 的二进制表示是：
```
0b00000000 00000001 00000000 10010010
```

对于 `int` 类型，这个值没有问题，可以完整地存储。然而，`short int` 只使用 **低 16 位** 来存储值，即：

```
0b10010010
```

这相当于 `146`（十进制表示为 `146`，但是对于有符号的 `short int`，它需要处理符号问题）。

然而，`146` 仍然在 `short int` 的范围内，因此在解释为 `short int` 时，它被打印为 **82**（即 `146 - 128 = 82`，因为符号位没有被占用）。

这种截断相当于用一个整数除以256，只保留其余数。用专业术语来说，该数字被解释成“以256为模”（modulo 256）， 即该数字除以256后取其余数。

##### 转换说明修饰符
在%和转换字符之间插入修饰符可修饰基本的转换说明。
![image.png|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-09-11-ec7a5af00fa506414fbfbef3a5c14c56-20240914160911-5a1213.png)
![image.png|775](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-10-32-37499ddab511efc23ceaf7789b6d008e-20240914161032-3cd8ed.png)

##### 参数传递错误
```c
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

该调用告诉计算机把变量n1、n2、、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明 printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是 n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。

![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-19-14-9f5a0b896d913ae356a292f9fe2b938c-20240914161913-e101b7.png)

##### 字符串断行
有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。
```c
printf("The printf() function printed %d characters.\n", 
rv);
```

方法1：使用多个printf()语句。因为第1个字符串没有以\n字符结束，所以第2个字符串紧跟第1个字符串末尾输出。
```c
printf("Here's one way to print a "); printf("long string.\n");
```

方法2：用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。
```c
printf("Here's another way to print a \
long string.\n");
```

方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下3 种形式是等效的：
```c
printf("Hello, young lovers, wherever you are."); 
printf("Hello, young " "lovers" ", wherever you are."); 
printf("Hello, young lovers" 
", wherever you are.");
```

但是，不能在双引号括起来的字符串中间断行。C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n 来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行符。


#### scanf
scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。 
scanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指针。
```c
int age;
scanf("%d",age);
```

##### 分隔机制

scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入：
```c
int age; // 变量 
float assets; // 变量
scanf("%d %f", &age, &assets); 
```

输入：
```c
42 2121.45
```

##### 转换说明
scanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。
![image.png|1000](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-50-18-97b0856c62b94f4db9c9e37808d7152c-20240914165018-3d68a0.png)


![image.png|975](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-48-13-fe0bb90ca86577df69c8d29b5a0f8382-20240914164812-5aaf52.png)

#####  输入机制
* 以`%d`为例：
	**读取机制**：scanf()函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。

	**停止条件**：scanf()不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后， scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。

如果第1个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入。用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法 （指数记数法）和新增的p记数法（十六进制指数记数法）。

* 以`%s`为例：
	**读取机制**：scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符
	
	**停止条件**：直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串。


当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\\0'，让数组中的内容成为一个C字符串。

##### 格式字符串中的普通字符
scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。
```c
 scanf("%d,%d", &n, &m);
```
 scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数： `88,121` 
 由于格式字符串中，%d后面紧跟逗号，所以必须在输入88后再输入一个逗号。

除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因此，`scanf("%d%d", &n, &m)`与`scanf("%d %d", &n, &m)`的行为相同。对于`%c`，在格式字符串中添加一个空格字符会有所不同。例如，如果把`%c`放在格式字符串中的空格前面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，而`scanf(" %c", &ch)`则从第1个非空白字符开始读取。



## 运算符
### 基本运算符
* 赋值运算符
```c
bmw = 2002;
```

赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象（data object），与初始化区分。

![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/20-55-39-9f262e48bf56cf09be72a95855704fb8-20240914205538-a6f6db.png)
赋值行为从右往左进行。
```c
i = i + 1
```
意思是找出变量 i 的值，把该值加 1，然后把新值赋值变量i
![image.png|575](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/21-02-17-f5a67be239b930863e916c1b156f07b4-20240914210217-9f6736.png)




可修改的左值（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。这里，bmw是可修改的左值，2002是右值。右值可以是常量、变量或其他可求值的表达式（如，函数调用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。

* 加法运算符
一元运算：
```c
dozen = +12;
```
这样不会改变变量的值

二元运算：
加法运算符（addition operator）用于加法运算，使其两侧的值相加。例如，语句： 
```c
printf("%d", 4 + 20);
```


* 减法运算符
一元运算：
减号可用于标明或改变一个值的代数符号。
```c
dozen = -12;
```

二元运算：
减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。
```c
takehome = 224.00 – 24.00;
```

* 乘法运算符：
符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：
```c
cm = 2.54 * inch;
```


* 除法运算符：
循相同的模式。 5.2.6 除法运算符：/ C使用符号/来表示除法。/左侧的值是被除数，右侧的值是除数。例如，下面four的值是4.0:
```c
four = 12.0/3.0;
```

数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。而对于混合类型（整数和浮点数的除法），在进行除法运算前，整数会被转换成浮点数。

### 关系运算符
![image.png|850](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/21-34-17-7c7251cc1a24e74a218333b61264e664-20240914213416-30acaf.png)

### 逻辑运算符
![image.png|925](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-17-58-5d1c693ddcbf214f20f8c97cd3001838-20240916091758-8056f8.png)
假设exp1和exp2是两个简单的关系表达式（如car > rat或debt == 1000），那么： 当且仅当exp1和exp2都为真时，exp1 && exp2才为真； 如果exp1或exp2为真，则exp1 || exp2为真； 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。

### 条件运算符
C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式，该表达式使用`?:`条件运算符。该运算符分为两部分，需要 3 个运算对象。
```c
expression1 ? expression2 : expression3
```
如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2 的值相同；如果expression1为假（0），那么整个条件表达式的值与 expression3的值相同。
要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：
```c
max = (a > b) ? a : b;
```
如果a大于b，那么将max设置为a；否则，设置为b。

### 其他运算符
* 取模运算符：
求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”） 得3，因为13比5的两倍多3，即13除以5的余数是3。求模运算符只能用于整数，不能用于浮点数。

* 递增递减运算符：
递减运算符与递增运算符相似，以递增运算符为例，递增运算符（increment operator）执行简单的任务，将其运算对象递增 1。该运算符以两种方式出现。第1种方式，++出现在其作用的变量前面， 这是前缀模式；第2种方式，++出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。
```c
shoe = 2.0; 
while (++shoe < 18.5) { 
	foot = SCALE*shoe + ADJUST; 
	printf("%10.1f %20.2f inches\n", shoe, foot); 
}
```
首先，这样的while循环是如何工作的？很简单。shoe的值递增1，然后和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然后，shoe的值再递增1，重复刚才的步骤，直到shoe的值不小于18.5为止。注意，我们把shoe的初始值从3.0改为2.0，因为在对foot第1次求值之前， shoe  已经递增了1。
![|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/https/cdn.jsdelivr.net/gh/xuezhaorong/Picgo/Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/2024/09/14/22-04-13-08d1014cffe4b33939a5c28279b7ba39-22-04-07-08d1014cffe4b33939a5c28279b7ba39-20240914220406-01cbd1-168e98.png)
单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。

![image.png|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/22-05-54-67f57fa33ca0b6eca311a95cdc9b5139-20240914220554-520b28.png)

递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++表示的是(x)*(y++)，而不是(x+y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。

* 其他赋值运算符
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/21-38-52-e007450c80b0b9a77e79e5335cbbb9b0-20240915213851-6d2061.png)


### 运算符优先级与运算顺序
![image.png](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/20-26-20-4765bc3449e3bb50a001410fcae7ed48-20240915202619-c0bbe2.png)

对于逻辑运算符，!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。因此，表达式a >b && b > c || b > d相当于((a > b) && (b > c)) || (b > d)。也就是说，b介于a和c之间，或者b大于d。

C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。
## 语句
### 循环语句
#### while
while循环的通用形式如下：
```c
while ( expression ) 
statement
```

expression是值之间的比较，可以使用任何表达式。如果expression为真 （或者更一般地说，非零），执行 statement部分一次，然后再次判断 expression。在expression为假（0）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代（iteration）。

![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/20-47-21-87ef08400fd45928e5e9c0240066819d-20240915204721-176d1d.png)
while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index < 5)。该表达式是一个入口条件（entry condition），因为必须满足条件才能进入循环体。对于真值，非零数为真值，而零为假值。

```c
int n = 0; 
while (n++ < 3){
	printf("n is %d\n", n);
}
```

#### for
for语句使用3个表达式控制循环过程，分别用分号隔开。initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真 （或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。

```c
for ( initialize; test; update ) 
statement //在test为假或0之前，重复执行statement部分。
```

 关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。第1个表达式是初始化，只会在for循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于 NUMBER时），循环结束。第3个表达式执行更新，在每次循环结束时求值。程序清单6.10用这个表达式递增count 的值，更新计数。完整的for语句还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。

```c
int count; 
for (count = 1; count <= NUMBER; count++) 
	printf("Be my Valentine!\n");
```

![image.png|700](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/20-59-29-36df0a3380b0cb2b56817e439349c629-20240915205928-5049de.png)

#### do while
出口条件循环：do while while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。
下面是do while循环的通用形式： 
```c
do 
statement 
while ( expression );
```
 do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而for循环或while循环都是在执行循环体之前先执行测试条件。
![|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/15/21-49-19-381cb713b6bbf2b14f6042138bfe1e2a-20240915214919-273b49.png)

### 分支语句
#### if
```c
 if ( expression ) 
 statement
```
如果对expression求值为真（非0），则执行statement；否则，跳过 statement。与while循环一样，statement可以是一条简单语句或复合语句。if 语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x > y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行 statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。
![Uploading file...himsu]()

#### if else
简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。 C还提供了if else形式，可以在两条语句之间作选择。
```c
if ( expression ) 
	statement1
else 
	statement2
```
如果expression为真（非0），则执行statement1；如果expression为假或 0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。
![image.png|675](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/08-56-22-1bad2f8ff2943271206a0b6233dacd9e-20240916085621-3e9545.png)

#### else if
```c
if (score < 1000) 
	bonus = 0; 
else if (score < 1500) 
	bonus = 1; 
else if (score < 2000) 
	bonus = 2;
else
	...
```

如果程序中有许多if和else，else与离它最近的if匹配，除非最近的if被花括号括起来
![image.png|525](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-00-26-ac5bc199ec376e4ea8b621fd6cf5a91e-20240916090026-6420c6.png)

### 循环辅助
#### continue
3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-34-41-a72212e602af60aa24fbe561bf2f8347-20240916093441-caeffe.png)

#### break
程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。
![|725](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-35-34-3f2842cab17bcc62e84e42c5497d5cd7-20240916093534-63a16b.png)

### 多重选择
```c
switch ( 整型表达式) { 
case 常量1: 语句 <--可选 
case 常量2: 语句 <--可选 
default : <--可选语句 <--可选 
}
```
对紧跟在关键字 switch 后圆括号中的表达式求值。然后程序扫描标签列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否则，程序继续执行在switch后面的语句。
 switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式 （即，表达式中只包含整型常量）。不能用变量作为case标签。

![image.png|452](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/16/09-50-30-1126dfe1a370138b418883f0cb95bd47-20240916095029-b18384.png)
break让程序离开switch语句，跳至switch语句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开始执行到switch末尾。