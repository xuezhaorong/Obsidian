##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

**整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = `