##  基本数据类型
### 整型

| 数据类型  | 表达方式 | 存储大小  | 表达范围                                      |
| ----- | :--: | ----- | ----------------------------------------- |
| short |      | 16    | $-2^{16}$~$2^{16}-1$                      |
| int   |      | 16/32 | $-2^{16}$~$2^{16}-1$/$-2^{32}$~$2^{32}-1$ |
| long  |  L   | 32    | $-2^{32}$ ~ $2^{32}-1$                    |

**表达范围说明**：
- **符号位**：占用 1 位，用于表示数值的正负。
- **数值位**：剩下的 31 位用于表示具体数值。
正数范围：
对于正数和零，最高位（符号位）为 0，其余的 31 位用于表示数值。因此，最大正数是当所有 31 位全为 1 时：
```
01111111 11111111 11111111 11111111
```
这个二进制数表示的是 `2^31 - 1 = 2147483647`。
负数范围：
对于负数，最高位（符号位）为 1，其余 31 位用于表示负数的绝对值。在补码表示法中，最小的负数是当符号位为 1，其余 31 位全为 0 时：
```
10000000 00000000 00000000 00000000
```
这个二进制数表示的是 `-2^31 = -2147483648`。

#### **整数溢出**
整数的存储空间是有限的，因此它只能表示一定范围内的数值。例如，`int` 类型通常是 32 位，因此它可以表示的有符号整数范围是 `-2147483648` 到 `2147483647`（`-2^31` 到 `2^31 - 1`）。当进行加法、减法、乘法等运算时，如果结果超出了这个范围，便会发生溢出。
```c
int main() {
    int max = 2147483647; // 32 位有符号整数的最大值
    int result = max + 1; // 上溢
    printf("%d",max);
    return 0;
}
```

在上面的代码中，`max` 是 32 位有符号整数的最大值 `2147483647`。当我们给它加 1 时，结果会超过 `int` 类型的最大表示范围，导致上溢。由于整数溢出，结果会变成 `-2147483648`，即从正数溢出了一个循环，回到最小的负数。

**有符号整数和无符号整数的溢出:**
有符号和无符号整数溢出的表现是不同的。
- **有符号整数**（`signed int`）溢出时，正溢出会变成负数，负溢出会变成正数。这是因为有符号整数使用了 **二进制补码** 来表示负数。补码的性质导致了在上溢或下溢时，数值会在正数和负数之间“循环”。
    
    - 上溢：`2147483647 + 1 = -2147483648`
    - 下溢：`-2147483648 - 1 = 2147483647`
- **无符号整数**（`unsigned int`）没有符号位，因此它表示的范围是从 `0` 到最大正整数。如果无符号整数发生溢出，它会从最大值循环回到 `0`，而不会有负数出现。
    
    - 上溢：`4294967295 + 1 = 0` （对于 32 位 `unsigned int`）
    - 下溢：`0 - 1 = 4294967295`


其他类型：

| 数据类型 | 表达方式        |
| ---- | ----------- |
| 无符号  | unsigned __ |
| 八进制  | 0__         |
| 十六进制 | 0x__        |

### 字符型
字符常量表达方式：`char grade = 'A'`
转义字符表达方式：`char grade = '/f'`
ASKII码表达方式: `char grade = 65`
八进制表达方式： `char grade = '\007'`
十六进制表达方式： `char grade = '\0x010'`

### 浮点型

|  数据类型  | 表达方式 | 存储大小 |
| :----: | :--: | :--: |
| float  |  f   |  32  |
| double |  f   |  64  |

存储结构：
浮点型先转成二进制数再使用科学计数法表达
例如：$-8.25=1000.01=-1.00001 * 2^{3}$

* 符号位为：1
* 指数位为：3+127=130=10000010 使用偏移法，+127解决负指数没有符号位存储的问题 范围为 `-126` 到 `127`（用偏移量127表示的范围是 `1` 到 `254`），`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`）。
* 尾数位为：00001，
则内存表示为：
![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/11-48-32-6a9d287590962e528826adde6f945edd-20240914114831-bff660.png)
`float`用1位表示符号位，8位表示指数位，23位标识尾数位
`double`用1位表示符号位，8位表示指数位，23+32位标识尾数位

#### 单精度浮点数可表示的最大值：
为了求出单精度浮点数能表示的最大值，我们需要让指数和尾数都达到它们的最大值。

**1. 最大尾数**

尾数由 23 位表示，加上隐含的前导 `1`，最大尾数可以表示为：

$1.111…111(23 个 1)$

这个尾数表示的值是接近于 2 的值，即：

$1.111…111=2−2^{−23}$

**2. 最大指数**

8 位的指数位可以表示的范围是 `0` 到 `255`。但是，`0` 和 `255` 被保留用于表示特殊值（如 `0` 和 `inf`），所以指数的有效范围是 `1` 到 `254`。

在偏移 127 的情况下，最大可表示的指数值为：

$254−127=127$

这意味着指数部分表示的最大值为 $2^{127}$。

**3. 计算最大浮点数值**

将最大指数和最大尾数带入公式：

$最大浮点数=(2−2^{−23})×2^{127}$

简化后，这个值非常接近于：

$最大浮点数≈2×2^{127}=2^{128}$

转换为十进制：

$2^{128}≈3.4028235×10^{38}$

因此，单精度浮点数的最大可表示值大约是 $**3.4 × 10^{38}**$。

#### 浮点型溢出

**浮点型的上溢：**
在单精度浮点数（32位）的情况下，结果超出可表示的最大值，通常会被处理为 `inf`。

**浮点型的下溢：**
当除以一个非常小的数或非常大的数时，会遇到 **下溢（underflow）** 的问题。在这种情况下，数值会进入 **非正规数（subnormal）** 的范围。

通常，浮点数是按照 **规范化**（normalized） 的形式表示的。规范化的浮点数必须是以1开头的二进制数，形式为：
$(−1)^{sign}×1.fraction×2^{exponent−127}$

**非正规数（subnormal number）**：当浮点数太小，以至于不能再用 `1.xxx` 这种形式表示时，指数达到最小值 `0`，并且尾数的格式变为 `0.xxx`。此时，浮点数的表示不再遵循规范化的形式，而是：
$(−1)^{sign}×0.fraction×2^{−126}$
这是为了能够表示比最小正常数更小的数值，但代价是**精度降低**，因为不再有隐含的 `1` 作为尾数的起点。

当我们将一个 **非常小** 的浮点数除以 2 时，指数部分应该减小。但如果这个数已经是最小指数（`-126`）的正常数，再继续将它除以 2，将导致数值小于能表示的最小正常数，这时浮点数进入了 **非正规数** 的区域。

**非正规数的行为**：非正规数的指数不再减小，指数保持为 `-126`，而是通过尾数的移位来减小数值。这意味着当我们将数除以2时，尾数部分的位会向右移，最右边的位会被丢弃，精度也因此降低。

例如：
假设最小的正常数是： 
$1.00000000000000000000000×2^{−126}$

将这个数除以 2 后，我们得到： 
$0.10000000000000000000000×2^{−126}$

因为尾数不再能表示 `1.0000...` 这种形式，而是 `0.1000...`，所以它变成了非正规数。
继续下溢：

如果我们继续将这个非正规数除以 2，尾数会进一步右移，最终所有的位会变成 `0`，结果是： $0.000000000000000000000002×2^{−126} = 0$

这就是下溢的最终结果——当尾数的精度已经不足，进一步的运算将导致数值接近或等于零。

#### **舍入误差：**
```c
#include <stdio.h> 
int main(void) { 
	float a,b; 
	b = 2.0e20 + 1.0; 
	a = b - 2.0e20; 
	printf("%f \n", a); return 0; 
}
```

当我们对一个非常大的数（如 `2.0e20`）加上一个非常小的数（如 `1`）时，**精度不足** 导致了计算误差。
- `2.0e20` 表示 `2 × 10^20`，它等于 **2后面跟着20个零**，即 `200000000000000000000`。
- 如果我们对 `2.0e20` 加上 `1`，从数学上来说，结果应该是 `200000000000000000001`。

但是，**问题在于浮点数精度的限制**。对于一个像 `2.0e20` 这么大的数，计算机只能存储前 6-7 位有效数字，后面的数字则被舍入。因此，当我们加 `1` 时，计算机没有足够的位数来存储这个变化。`1` 的影响太小，它在浮点数的表示中被舍掉了。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。

#### 浮点型精度误差
在 **IEEE 754 标准**中，浮点数是由 **符号位**、**指数** 和 **尾数** 组成的。虽然这种表示方式允许我们用较少的存储空间来表示非常大的数和非常小的数，但它有一个缺点：**某些十进制小数无法被精确表示成二进制形式**。

例如：

- 十进制的 `0.1` 在二进制中是一个无限循环小数：`0.0001100110011001100110011...`。
- 计算机只能保留有限的位数，因此它只能存储 `0.1` 的近似值。

即使对于看似简单的浮点数 `1.0`，它在计算机内部存储时也会近似表示。因此，当你进行浮点数运算时，误差可能会累积，导致结果不完全等于期望值。在某些情况下，由于浮点数的存储误差，**`1.0`** 可能不会被精确地表示为真正的 `1.0`，而是非常接近 `1.0` 的一个值。例如：
- 如果 `1.0` 实际上被存储为 `0.9999999999999999`（略小于 `1.0`），那么 `1.0 - 1.0` 的结果可能会是一个非常小的数，而不是严格的 `0`。
浮点运算可能得到的结果是一个 **接近零的值**，但不是精确的零，其他数字的计算也是如此。

## 字符串和格式化输出输入
### 字符串
```c
#include <string.h>
int main(){
	char name[40];
	scanf("%s:",&name);
	return 0;
}
```
字符串（character string）是一个或多个字符的序列，字符串都被储存在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。
![image.png|775](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-41-56-de21d566e36ed83fafba7a5b8c7c7ddc-20240914144155-3b953b.png)
数组末尾位置的字符\0。这是空字符（null character），C 语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII 码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。

使用双引号规定字符串，自动在末尾加入空字符。
#### strlen
```c
unsigned long length = strlen(name);
```
strlen() 函数给出字符串中的字符长度，不计入最后的空字符。
![image.png|750](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-46-58-d16cd6e11b821b13d7e28398808936ab-20240914144657-a61062.png)

### printf

printf()函数能让用户可以与程序交流，它输出函数，请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如， 打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明 （conversion specification），它们指定了如何把数据转换成可显示的形式。
![image.png|825](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/14-56-22-58b3266ec99c5ff07b500444dddee0ce-20240914145622-bbccab.png)

空参数问题：
```c
printf("%d,%hd",word);
```
输出：
```c
65618,21664
```

由于没有给第二个转换符号具体参数，所以打印出的值是内存中的任意值


#### 转换说明

| 数据类型     |     |
| -------- | --- |
| short    | %h  |
| int      | %d  |
| long     | %l  |
| unsigned | %u_ |
| 八进制      | %o  |
| 十六进制     | %x  |
| 字符串      | %s  |
| %        | %%  |

**转换不匹配问题：**
* 有符号与无符号
```c
short num = 336;
printf("%hd,%hu",num,num);
```
输出：
` -336 65200`
系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534 表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解释成有符号int时，65200代表-336。

* 大字节与小字节
```c
int word = 65618;  
printf("%d,%hd",word,word);
```
输出：
`65618,82`

第二项使用了 `%hd`，它要求 `word` 被解释为 `short int`，即它会将 `word` 的低 16 位当作一个 `short int` 来处理。
`65618` 的二进制表示是：
```
0b00000000 00000001 00000000 10010010
```

对于 `int` 类型，这个值没有问题，可以完整地存储。然而，`short int` 只使用 **低 16 位** 来存储值，即：

```
0b10010010
```

这相当于 `146`（十进制表示为 `146`，但是对于有符号的 `short int`，它需要处理符号问题）。

然而，`146` 仍然在 `short int` 的范围内，因此在解释为 `short int` 时，它被打印为 **82**（即 `146 - 128 = 82`，因为符号位没有被占用）。

这种截断相当于用一个整数除以256，只保留其余数。用专业术语来说，该数字被解释成“以256为模”（modulo 256）， 即该数字除以256后取其余数。

#### 转换说明修饰符
在%和转换字符之间插入修饰符可修饰基本的转换说明。
![image.png|625](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-09-11-ec7a5af00fa506414fbfbef3a5c14c56-20240914160911-5a1213.png)
![image.png|775](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-10-32-37499ddab511efc23ceaf7789b6d008e-20240914161032-3cd8ed.png)

#### 参数传递错误
```c
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

该调用告诉计算机把变量n1、n2、、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明 printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是 n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。

![image.png|500](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-19-14-9f5a0b896d913ae356a292f9fe2b938c-20240914161913-e101b7.png)

#### 字符串断行
有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。
```c
printf("The printf() function printed %d characters.\n", 
rv);
```

方法1：使用多个printf()语句。因为第1个字符串没有以\n字符结束，所以第2个字符串紧跟第1个字符串末尾输出。
```c
printf("Here's one way to print a "); printf("long string.\n");
```

方法2：用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。
```c
printf("Here's another way to print a \
long string.\n");
```

方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下3 种形式是等效的：
```c
printf("Hello, young lovers, wherever you are."); 
printf("Hello, young " "lovers" ", wherever you are."); 
printf("Hello, young lovers" 
", wherever you are.");
```

但是，不能在双引号括起来的字符串中间断行。C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n 来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行符。


### scanf
scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。 
scanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指针。
```c
int age;
scanf("%d",age);
```

#### 分隔机制

scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入：
```c
int age; // 变量 
float assets; // 变量
scanf("%d %f", &age, &assets); 
```

输入：
```c
42 2121.45
```

#### 转换说明
scanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。
![image.png|1000](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-50-18-97b0856c62b94f4db9c9e37808d7152c-20240914165018-3d68a0.png)


![image.png|975](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/16-48-13-fe0bb90ca86577df69c8d29b5a0f8382-20240914164812-5aaf52.png)

####  输入机制
* 以`%d`为例：
	**读取机制**：scanf()函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。

	**停止条件**：scanf()不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后， scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。

如果第1个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入。用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法 （指数记数法）和新增的p记数法（十六进制指数记数法）。

* 以`%s`为例：
	**读取机制**：scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符
	
	**停止条件**：直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串。


当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\\0'，让数组中的内容成为一个C字符串。

#### 格式字符串中的普通字符
scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。
```c
 scanf("%d,%d", &n, &m);
```
 scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数： `88,121` 
 由于格式字符串中，%d后面紧跟逗号，所以必须在输入88后再输入一个逗号。

除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因此，`scanf("%d%d", &n, &m)`与`scanf("%d %d", &n, &m)`的行为相同。对于`%c`，在格式字符串中添加一个空格字符会有所不同。例如，如果把`%c`放在格式字符串中的空格前面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，而`scanf(" %c", &ch)`则从第1个非空白字符开始读取。



### 运算符，表达式和语句
#### 基本运算符
* 赋值运算符
```c
bmw = 2002;
```

赋值行为从右往左进行。赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象（data object），与初始化区分。

![image.png](https://cdn.jsdelivr.net/gh/xuezhaorong/Picgo//Source/fix-dir/picgo/picgo-clipboard-images/2024/09/14/20-55-39-9f262e48bf56cf09be72a95855704fb8-20240914205538-a6f6db.png)
